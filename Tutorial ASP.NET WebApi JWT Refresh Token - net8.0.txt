ASP.NET WebApi JWT Refresh Token
--------------------------------

. Acesse a pasta central de projetos e execute o comando abaixo:

    dotnet new webapi -o superRefreshTokenApp -n superRefreshTokenApp -f net8.0 --use-controllers

. Acesse a pasta do projeto criado e execute os comandos abaixo:

    dotnet add package Microsoft.AspNetCore.Authentication --version 2.3.0

    # dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 9.0.3
    dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 8.0.14


. Altere o atributo "<Nullable>" para "disable" para impedir os "Warnings" de objeto nulo

    <Project Sdk="Microsoft.NET.Sdk.Web">

        <PropertyGroup>
            <TargetFramework>net8.0</TargetFramework>
            <Nullable>disable</Nullable>                <!-- linha alterada -->
            <ImplicitUsings>enable</ImplicitUsings>
        </PropertyGroup>

        ...
    </Project>

. Crie a pasta "Models" na raiz do projeto e dentro dela crie a classe abaixo:

    namespace superRefreshTokenApp.Models;

    public class User
    {
        public int Id { get; set; }

        public string Username { get; set; }

        public string Password { get; set; }

        public string Role { get; set; }

    }

. Crie a pasta "Repositories" na raiz do projeto e dentro dela crie a classe abaixo:

    using superRefreshTokenApp.Models;

    namespace superRefreshTokenApp.Repositories;

    public class UserRepository
    {
        public static User Get(string username, string password)
        {
            var users = new List<User>
                    {

                        new() { Id = 1, Username = "batman", Password = "batman", Role = "manager" } ,
                        new() { Id = 2, Username = "robin", Password = "robin", Role = "employee" }
                    };

            return users.FirstOrDefault(x => x.Username == username && x.Password == password);
        }
    }

. Na raiz do projeto crie a classe "Settings":

    namespace superRefreshTokenApp;

    public static class Settings
    {
        public static string JwtKey = "ZmVkYWY3ZDg4NjNiNDhlMTk3YjkyODdkNDkyYjcwOGU=";

        public static string ApiKeyName = "api_key";
        public static string ApiKey = "curso_api_IlTevUM/z0ey3NwCV/unWg==";
        public static int TokenExpireIn = 10800;
        public static string TokenExpireInUnit = "seconds";

    }

. Crie a pasta "Services" e dentro dela a classe abaixo:

    using System.IdentityModel.Tokens.Jwt;
    using System.Security.Claims;
    using System.Security.Cryptography;
    using System.Text;
    using Microsoft.IdentityModel.Tokens;
    using superRefreshTokenApp.Models;

    namespace superRefreshTokenApp.Services;

    public class TokenService
    {
        private List<(string, string, string)> _refreshTokens; //  = new();

        public TokenService()
        {
            _refreshTokens = new();
        }

        public string GenerateToken(User user)
        {
            // Classe responsável por gerar o token
            var tokenHandler = new JwtSecurityTokenHandler();

            // Nossa chave de validação do token
            var key = Encoding.ASCII.GetBytes(Settings.JwtKey);

            // Informações contidas no nosso token
            var tokenDescriptor = new SecurityTokenDescriptor()
            {
                // Perfis dos usuários
                Subject = new ClaimsIdentity(new Claim[]
                {
                            new Claim( ClaimTypes.Name, user.Username ),    // Aponta para User.Identity.Name
                            new Claim( ClaimTypes.Role, user.Role )         // Aponta para User.InRole
                }),
                // Tempo de expiração do nosso token
                // Expires = DateTime.UtcNow.AddHours(8),
                // Tempo de expiração do nosso token
                Expires = Settings.TokenExpireInUnit.Equals("seconds") ? DateTime.UtcNow.AddSeconds( Settings.TokenExpireIn ):
                                                                            DateTime.UtcNow.AddHours(   Settings.TokenExpireIn ),
                // Credenciais para incriptar e desincriptar nosso token
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key),
                                                                SecurityAlgorithms.HmacSha256Signature)
            };

            // Faz a criação do token
            var token = tokenHandler.CreateToken(tokenDescriptor);

            return tokenHandler.WriteToken(token);

        }

        // 7.52
        public string GenerateToken(IEnumerable<Claim> claims)
        {
            var tokenHandler = new JwtSecurityTokenHandler();

            var key = Encoding.ASCII.GetBytes(Settings.JwtKey);

            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.UtcNow.AddHours(2),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key),
                                        SecurityAlgorithms.HmacSha256Signature)
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);

            return tokenHandler.WriteToken(token);
        }

        // 8.24
        public string GenerateRefreshToken()
        {
            var randomNumber = new byte[32];

            using var rng = RandomNumberGenerator.Create();

            rng.GetBytes(randomNumber);

            return Convert.ToBase64String(randomNumber);
        }

        // 9.20
        public ClaimsPrincipal GetPrincipalFromExpiredToken(string token)
        {
            var tokenValidationParameters = new TokenValidationParameters
            {
                ValidateAudience = false,
                ValidateIssuer = false,
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Settings.JwtKey)),
                ValidateLifetime = false
            };

            var tokenHandler = new JwtSecurityTokenHandler();

            try
            {
                var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out var securityToken);

                if (securityToken is not JwtSecurityToken jwtSecurityToken ||
                        !jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256,
                                                                StringComparison.InvariantCultureIgnoreCase))
                    throw new SecurityTokenException("Invalid Token");

                return principal;
            }
            catch (Exception ex)
            {
                throw new SecurityTokenException("Invalid Token");
            }            
        }

        // 11.26
        public void SaveRefreshToken(string username, string token, string refreshToken)
        {

            int index = _refreshTokens.FindIndex(x => x.Item1 == username);

            if (index == -1)
                _refreshTokens.Add(new(username, token, refreshToken));
            else
                _refreshTokens[index] = new(username, token, refreshToken);
        }

        public string GetRefreshToken(string username)
        {
            return _refreshTokens.FirstOrDefault(x => x.Item1 == username).Item3;
        }

        public string GetToken(string username)
        {
            return _refreshTokens.FirstOrDefault(x => x.Item1 == username).Item2;
        }

        public void DeleteRefreshToken(string username, string refreshToken)
        {

            // ATENÇÃO: Verificar se "x.items2 == refreshToken ).item2;" está correto

            var item = _refreshTokens.FirstOrDefault(x => x.Item1 == username &&
                                                        x.Item3 == refreshToken);

            _refreshTokens.Remove(item);
        }
    }


    . Acesse a classe "Programs.cs" e insira as linhas abaixo para habilitar a autenticação e a autorização 
        no nosso projeto, obrigatório ser nessa ordem:

        using System.Text;                                          // Linha inserida
        using superRefreshTokenApp;                                 // Linha inserida
        using Microsoft.AspNetCore.Authentication.JwtBearer;        // Linha inserida
        using Microsoft.IdentityModel.Tokens;                       // Linha inserida

        ...
        var builder - WebApplication.CreateBuilder( args );

        builder.Services.AddSingleton<TokenService>();  // Linha inserida

        builder.Services.AddControllers();               // Linha inserida
        builder.Services.AddAuthorization();             // Linha inserida

        var key = Encoding.ASCII.GetBytes( Settings.JwtKey );   // Linha inserida

        // Linha abaixo inserida, não é para alterar
        builder
            .Services
            .AddAuthentication(x =>
                                    {
                                        x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                                        x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
                                    })
            .AddJwtBearer(x =>
                                    {
                                        x.RequireHttpsMetadata = false;             
                                        x.SaveToken = true;
                                        x.TokenValidationParameters = new TokenValidationParameters
                                        {
                                            ValidateIssuerSigningKey = true,
                                            IssuerSigningKey = new SymmetricSecurityKey(key),
                                            ValidateIssuer = false,
                                            ValidateAudience = false
                                        };
                                    });

        // Linha Inserida
        builder.Services.Configure<RouteOptions>(options =>
        {
            options.LowercaseUrls = true; // Força URLs em minúsculas
        });

        ...
        var app = builder.Build();

        app.UseAuthentication();    // Linha inserida   "Nessa ordem"
        app.UseAuthorization();     // Linha inserida   "Nessa ordem"

        app.MapControllers();       // Linha inserida

        ...

        app.UseHttpsRedirection();

        // Apague o bloco de código abaixo
        /*  
        var summaries = new[]
        {
            "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
        };

        app.MapGet("/weatherforecast", () =>
        {
            var forecast = Enumerable.Range(1, 5).Select(index =>
                new WeatherForecast
                (
                    DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                    Random.Shared.Next(-20, 55),
                    summaries[Random.Shared.Next(summaries.Length)]
                ))
                .ToArray();
            return forecast;
        })
        .WithName("GetWeatherForecast")
        .WithOpenApi();
        */

        app.Run();

        // Apague o bloco de código abaixo
        /*
        record WeatherForecast(DateOnly Date, int TemperatureC, string Summary)
        {
            public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
        }
        */

. Crie a pasta "Controllers" e crie a classe "LoginController" dentro dela:

    using System.Web;
    using Microsoft.AspNetCore.Mvc;
    using superRefreshTokenApp;
    using superRefreshTokenApp.Models;
    using superRefreshTokenApp.Repositories;
    using superRefreshTokenApp.Services;

    namespace superAuthApp.Controllers;
    [ApiController]
    [Route("[controller]")]
    public class LoginController : ControllerBase
    {

        [HttpPost("v1/getToken")]
        public ActionResult<dynamic> Authenticate([FromServices] TokenService tokenService,
                                                                    [FromBody] User model)
        {
            var user = UserRepository.Get(model.Username, model.Password);


            if (user == null)
            {
                return NotFound(new { message = "Usuário, ou senha, inválido" });
            }

            string token = tokenService.GenerateToken(user);

            string refreshToken = tokenService.GenerateRefreshToken();

            user.Password = "";

            return new // ObjectResult(new
                                    {
                                        user = user,
                                        token = HttpUtility.UrlDecode(token),
                                        tokenType = "Bearer",
                                        tokenExpireIn = Settings.TokenExpireIn,
                                        tokenExpireInUnit = Settings.TokenExpireInUnit,
                                        refreshToken = HttpUtility.UrlDecode(refreshToken)
                                    };
        }

        // 14.50
        [HttpPost("v1/getRefreshToken")]
        public IActionResult Refresh([FromServices] TokenService tokenService,
                                    [FromQuery] string token,
                                        [FromQuery] string refreshToken)
        {

            var principal = tokenService.GetPrincipalFromExpiredToken(token);

            var username = principal.Identity.Name;

            // TODO: Fazer a validação do Token como é feito com o RefreshToken

            var savedToken = tokenService.GetToken(username);

            var savedRefreshToken = tokenService.GetRefreshToken(username);

            if ( savedToken != token ) 
                // return Unauthorized(new ObjectResult( new { description =  "RefreshToken Inválido"} ) );
                return Unauthorized(new { Error = "Token Inválido" });

            if  (savedRefreshToken != refreshToken)
                // return Unauthorized(new ObjectResult( new { description =  "RefreshToken Inválido"} ) );
                return Unauthorized(new { Error = "RefreshToken Inválido" });
            //  throw new SecurityTokenException("Invalid Token");  // Ao invés de levantar um exception, devolver um StatusCode

            var newJwtToken = tokenService.GenerateToken(principal.Claims);
            var newRefreshToken = tokenService.GenerateRefreshToken();

            // tokenService.DeleteRefreshToken(username, refreshToken);
            tokenService.SaveRefreshToken(username, HttpUtility.UrlDecode(newJwtToken), HttpUtility.UrlDecode(newRefreshToken) );   // Salvar a data de criação/expiração para invalida-lo

            return new ObjectResult(new
                                    {
                                        user = username,
                                        token = HttpUtility.UrlDecode(newJwtToken),
                                        tokenType = "Bearer",
                                        tokenExpireIn = Settings.TokenExpireIn,
                                        tokenExpireInUnit = Settings.TokenExpireInUnit,
                                        refreshToken = HttpUtility.UrlDecode(newRefreshToken)
                                    });
        }

        // TODO  1. No método "tokenService.GenerateRefreshToken" deve guardar a data de expiração do refreshToken
        //       2. Criar método que gera novo token somente com o refreshToken
        //       3. Esse método deve validar a expiração do refreshToken
    }

. Acesse o controller "HomeController" e altere todo código dele como abaixo:

    using Microsoft.AspNetCore.Authorization;
    using Microsoft.AspNetCore.Mvc;

    namespace superTokenApp.Controllers;

    [ApiController]
    [Route("[controller]")]
    public class HomeController : ControllerBase
    {
        [HttpGet("v1/anonymous")]
        [AllowAnonymous]
        public string Anonymous() => "Anônimo";

        [HttpGet("v1/authenticated")]
        [Authorize]
        public string Authenticate() => $"Authenticated - {User.Identity.Name}";

        [HttpGet("v1/employee")]
        [Authorize(Roles = "employee,manager")]
        public string Employee() => "Funcionário";

        [HttpGet("v1/manager")]
        [Authorize(Roles = "manager")]
        public string Manager() => "Gerente";
    }

. Levante a aplicação

. Acesse o Postman e execute a rota abaixo:

    url: https://localhost:[porta]/login/v1/getToken
    method: POST
    Body.raw.JSON: True
    Body.raw:   {
        "username": "batman",
        "password": "batman"
    }

    . Copie o token e o refreshToken gerado

// 18.13
. Execute a rota abaixo:

    url: https://localhost:[porta]/login/v1/getRefreshToken
    method: POST
    Params.token: [token gerado no item anterior]
    Params.refreshToken: [Refresh Token gerado no passo anterior]
    Body.raw.JSON: True
    Body.raw:   {
        "username": "batman",
        "password": "batman"
    }

. Acesse o controller "HomeController" e altere todo código dele como abaixo:

    using Microsoft.AspNetCore.Authorization;
    using Microsoft.AspNetCore.Mvc;

    namespace superTokenApp.Controllers
    {
        [ApiController]
        [Route("[controller]")]
        public class HomeController: ControllerBase
        {
            [HttpGet("v1/anonymous")]
            [AllowAnonymous]
            public string Anonymous() => "Anônimo";

            [HttpGet("v1/authenticated")]
            [Authorize]
            public string Authenticate() => $"Authenticated - {User.Identity.Name}";

            [HttpGet("v1/employee")]
            [Authorize( Roles = "employee,manager")]
            public string Employee() => "Funcionário";

            [HttpGet("v1/manager")]
            [Authorize( Roles = "manager")]
            public string Manager() => "Gerente";
        }
    }

. Pare o projeto e execute novamente em modo debug

. Acesse o Postman e execute a requisição abaixo:

    url: https://localhost:[porta]/home/v1/anonymous
    method: GET 
    body.none: true

. Acesse o Postman e execute a requisição abaixo:

    url: https://localhost:[porta]/home/v1/authenticated
    method: GET 
    body.none: true

    . Dará erro "401. Unauthenticated"

    . No Postman reconfigure a requisição como abaixo:

        url: https://localhost:[porta]/home/v1/authenticated
        method: GET
        Authorization.Type: Bearer Token
        Authorization.Token: [token obtido no item anterior]

        ou

        url: https://localhost:[porta]/home/v1/authenticated
        method: GET
        Headers.Authorization: Bearer [Token obtido no item anterior]

        . Este NÃO DARÁ erro, retornando o "User.Identity.Name"

. Acesse o Postman e execute a requisição abaixo:

    url: https://localhost:[porta]/home/v1/employee
    method: GET
    Authorization.Type: Bearer Token
    Authorization.Token: [token obtido no item anterior]

    ou

    url: https://localhost:[porta]/home/v1/employee
    method: GET
    Headers.Authorization: Bearer [Token obtido no item anterior]

    . Este NÃO DARÁ erro, retornando o "Funcionário"

. Acesse o Postman e execute a requisição abaixo:

    url: https://localhost:[porta]/home/v1/manager
    method: GET
    Authorization.Type: Bearer Token
    Authorization.Token: [token obtido no item anterior]

    ou

    url: https://localhost:[porta]/home/v1/manager
    method: GET
    Headers.Authorization: Bearer [Token obtido no item anterior]

    . Este DARÁ erro, retornando status Code "403. Forbidden"

. Acesse o Postman e execute a requisição abaixo:

    url: https://localhost:[porta]/login/v1/getToken
    method: POST
    body.raw: true
    body.raw.json: True
    body:   {
                "username": "batman",
                "password": "batman"
            }

    . Guarde o Token gerado para ser utilizado logo mais.

. Acesse o Postman e execute a requisição abaixo:

    url: https://localhost:[porta]/home/v1/manager
    method: GET
    Authorization.Type: Bearer Token
    Authorization.Token: [token obtido no item anterior]

    ou

    url: https://localhost:[porta]/home/v1/manager
    method: GET
    Headers.Authorization: Bearer [Token obtido no item anterior]

    . Este NÃO DARÁ erro, retornando o valor "Gerente"

