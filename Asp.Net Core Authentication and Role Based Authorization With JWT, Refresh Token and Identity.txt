Asp.Net Core Authentication and Role Based Authorization With JWT, Refresh Token and Identity
---------------------------------------------------------------------------------------------

1. Video tutorial

    https://www.youtube.com/watch?v=EnHrfJO0gyE&list=PL7yxJa4Na-ir9DLuPL_8kYhyHJXCoPyaR

    . Os fontes do projeto desenvolvido estão na URL abaixo:

        https://github.com/rd003/DotnetApiCompleteAuth

2. Enviroment

    . Instalação para as versões acima do Ubuntu 22.04

        wget https://dot.net/v1/dotnet-install.sh
        chmod +x dotnet-install.sh

        export DOTNET_INSTALL_DIR=$HOME/.dotnet 
        
        ./dotnet-install.sh --install-dir $HOME/.dotnet -c 3.1
        ./dotnet-install.sh --install-dir $HOME/.dotnet -c 5.0
        ./dotnet-install.sh --install-dir $HOME/.dotnet -c 6.0
        ./dotnet-install.sh --install-dir $HOME/.dotnet -c 7.0

        dotnet --version

        # Caso o comando "dotnet" não se comportar como um executável, crie o link abaixo:
        sudo ln -s /home/$USER/.dotnet/dotnet /usr/bin/dotnet

        # insira as linhas abaixo no arquivo ".bashrc"
        echo 'export PATH="$HOME/.dotnet:$HOME/.dotnet/tools:$PATH"' >> ~/.bashrc
        echo 'export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1' >> ~/.bashrc
        echo 'export DOTNET_ROOT=$HOME/.dotnet' >> ~/.bashrc

        source ~/.bashrc

        # insira as linhas abaixo no arquivo ".zshrc"
        echo 'export PATH="$HOME/.dotnet:$HOME/.dotnet/tools:$PATH"' >> ~/.zshrc
        echo 'export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1' >> ~/.zshrc
        echo 'export DOTNET_ROOT=$HOME/.dotnet' >> ~/.zshrc

        source ~/.zshrc

        dotnet --version
        dotnet --list-runtimes
        dotnet --list-sdks

    . Instalação das extensões do VSCode

            C# 
            C# Extensions (JosKreativ)
            C# XML Documentation Comments
            C# Snippets
            Docker
            SQLTools
            SQLTools MySQL/MariaDB/...


    . Instalação do Nodejs

        curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | $SHELL

        echo 'export PATH="/home/$USER/.nvm:$PATH"' >> ~/.bashrc
        echo 'export NVM_DIR="$HOME/.nvm"' >> ~/.bashrc 

        nvm --version

        # Para instalar a versão lts mais recente
        nvm install --lts

        # Se quiser instalar uma versão especifica, utilize:
        # nvm install 18.20.4

        # Se quiser listar as versões do node disponivel no repositorio remoto
        # nvm ls-remote

        # Se quiser listar as versões instalada na máquina atual
        # nvm ls

        # Para usar uma versão instalada na máquina atual
        # nvm use 20.17.0

        # Para desinstalar uma versão do node js
        # nvm uninstall 18.20.4

        node -v
        npm -v

    . Instalação do Git

        sudo apt-get install git
        git --version
        git config --global user.name "maransi"
        git config --global user.email "maransi"
        git config --list

        . Importante: Verifique como trabalhar com "Branchs" no curso "Resumo do Curso Git", principalmente na parte 
                        "6. Trabalhando com "Branchs"


    . Instalação do Docker

        # Acesse o paragrafo "Install Docker Desktop" e execute o passo a passo

        # Ubuntu
        https://docs.docker.com/desktop/setup/install/linux/ubuntu/

            . Instalação de 05/2025

                sudo apt-get update
                sudo apt-get install ca-certificates curl
                sudo install -m 0755 -d /etc/apt/keyrings
                sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
                sudo chmod a+r /etc/apt/keyrings/docker.asc

                echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
                $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

                sudo apt-get update
                sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                docker --version

                sudo groupadd docker
                sudo gpasswd -a $USER docker
                sudo chown "$USER":"$USER" /var/run/docker.sock -R
                docker --version
                docker ps -a

                sudo docker run hello-world

        # Debian
        https://docs.docker.com/desktop/setup/install/linux/debian/

    . Create Docker Container for Database MySQL

        . Instalação do MySQL:

            sudo apt update && sudo apt upgrade -y  

            sudo apt install libaio1

            cd ~/Downloads

            sudo wget https://dev.mysql.com/get/mysql-apt-config_0.8.29-1_all.deb
            
            # Na janela gráfica deixe as opções marcadas ou escolha se você souber o que está fazendo > enter > enter > tab > OK > enter.
            sudo dpkg -i mysql-apt-config_0.8.29-1_all.deb
            
            # Na janela gráfica deixe as opções marcadas ou escolha se você souber o que está fazendo > enter > enter > tab > OK > enter.
            sudo dpkg-reconfigure mysql-apt-config

            # File '/usr/share/keyrings/mysql-apt-config.gpg' exists. Overwrite? (y/N) y
            
            sudo dpkg -i mysql-apt-config_0.8.29-1_all.deb
            
            sudo dpkg-reconfigure mysql-apt-config
            
            sudo apt update
            
            sudo apt install mysql-server
            
            mysql -u root -p 
            
        . Instalação do container do MySQL

            docker pull mysql
            docker images

            . Executando o container MySQL criado:
            
                . Executando o Container do MySQL no localhost numa porta diferente 3003:

                    docker run -e MYSQL_ROOT_PASSWORD=root --name dotnetdb -d -p 3003:3306 mysql:8.0
                    docker start dotnetdb
                    docker ps
                    
                    mysql -u root -p -h 127.0.0.1 -P 3003	
                    ou 
                    mysql -uroot -proot -h172.17.0.2

                    docker stop c342845054d1 		
                    ou 	
                    docker stop dotnetdb


3. Creating a new project


    . Digite os comandos abaixo na pasta de projetos:

        dotnet new sln -o DotnetApiCompleteAuth

        cd DonetApiCompleteAuth

        dotnet new webapi --use-controllers -n DotnetApiCompleteAuth -o ./src/DotnetApiCompleteAuth --no-openapi -f net8.0 
        # dotnet new webapi --use-controllers -n DotnetApiCompleteAuth -o ./src/DotnetApiCompleteAuth  -f net8.0

        dotnet sln add ./src/DotnetApiCompleteAuth/DotnetApiCompleteAuth.csproj

        git init

        dotnet new gitignore --force

    . Acesse a pasta da solution com o VSCode

    . Apague o controller "./Controllers/WeatherForecastController.cs" e a classe "./WeatherForecast.cs"

    . Acesse o prompt do terminal e a pasta raiz da "solution" e execute o comando abaixo:

        dotnet clean

        dotnet build

        git add .

        git commit -am "feat: first commit"

4. Creating the PeopleController

    . Podemos criar um controller com o "dotnet cli"

    . Precisamos ter o pacote "Microsoft.VisualStudio.Web.CodeGeneration.Design" instalado no seu projeto de API para usar esse comando. 
        Se você não tiver esse pacote instalado, você pode instalá-lo usando o comando:

        cd src/DotnetApiCompleteAuth

        dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 8.0.7

        dotnet tool install -g dotnet-aspnet-codegenerator --version 9.0.0

    . Sintaxe


        dotnet aspnet-codegenerator controller -name NomeDoController -async -api -m NomeDoModelo -dc NomeDoDbContext -outDir Controllers

        . Este comando cria um novo controller com o nome especificado, com suporte a async/await, API e usando o modelo e contexto de dados especificados.

        . Aqui está uma explicação dos parâmetros:

            -name: especifica o nome do controller.
            -async: especifica que o controller deve ser criado com suporte a async/await.
            -api: especifica que o controller deve ser criado como um controller API.
            -m: especifica o nome do modelo que o controller deve usar.
            -dc: especifica o nome do contexto de dados que o controller deve usar.
            -outDir: especifica o diretório onde o controller deve ser criado.

    . Exemplo

        dotnet aspnet-codegenerator controller -name ProdutosController -async -api -m Produto -dc MeuDbContext -outDir Controllers  

        # dotnet aspnet-codegenerator controller -name PeopleController -async -api -outDir Controllers

    . Crie a classe "PeopleController.cs" dentro da pasta "Controllers" com o conteúdo abaixo, ou execute o comando "dotnet cli" acima:

        using Microsoft.AspNetCore.Http;
        using Microsoft.AspNetCore.Mvc;
        using Microsoft.AspNetCore.Authorization;

        namespace DotnetApiCompleteAuth.Controllers;

        [Route("api/[controller]")]
        [ApiController]
        public class PeopleController : ControllerBase
        {
            [HttpGet]
            public IActionResult GetPeople()
            {
                return Ok("People data");
            }

            [HttpPost]
            public IActionResult CreatePerson()
            {
                return Ok("Person is created");
            }
        }

    . Acesse a classe "Program.cs" e insira as linhas abaixo:

        using AspNetCore.Scalar;

        var builder = WebApplication.CreateBuilder(args);

        builder.Services.AddControllers();

        // Linha Inserida
        builder.Services.Configure<RouteOptions>(options =>
        {
            options.LowercaseUrls = true; // Força URLs em minúsculas
        });

        ...

    . Executando o projeto pela solution:

        dotnet clean

        dotnet restore

        dotnet build

        dotnet run --project DotnetApiCompleteAuth/ 

    . Executando o projeto diretamente pelo projeto:

        cd DotnetApiCompleteAuth

        dotnet clean

        dotnet restore

        dotnet build

        dotnet run

        # Caso ocorra alguma msg de warning (   Warning: Locale 'ru' does not match any known cultures.
        #                                       Warning: Failed to read or parse localization file .... )
        # Execute o comando abaixo:
        #
        # chmod -R u+r /home/marco/.dotnet/templates/ 
        #
        # e atualize o ".csproj" com a linha abaixo
        #
        #    <Project Sdk="Microsoft.NET.Sdk.Web">
        #
        #       <PropertyGroup>
        #           <TargetFramework>net8.0</TargetFramework>
        #           <Nullable>enable</Nullable>
        #           <ImplicitUsings>enable</ImplicitUsings>
        #
        #           <!-- Insira a linha abaixo -->
        #           <NoWarn>$(NoWarn);NETSDK1188</NoWarn>
        #       </PropertyGroup>
        #
        #   </Project>

    . Configurando o swagger

        . Acesse o terminal e execute o comando abaixo:

            cd src/DotnetApiCompleteAuth

            dotnet add package Swashbuckle.AspNetCore --version 8.1.1

        . Acesse a classe "Program.cs" e insira as linhas abaixo:

            var builder = WebApplication.CreateBuilder(args);

            // Add services to the container.

            builder.Services.AddControllers();

            builder.Services.AddEndpointsApiExplorer();         // linha inserida
            builder.Services.AddSwaggerGen();                   // Linha inserida


            var app = builder.Build();

            // Bloco inserido
            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();                               // Linha inserida
                app.UseSwaggerUI();                             // Linha inserida
            }


            app.UseHttpsRedirection();

            app.UseAuthorization();

            app.MapControllers();

            app.Run();

        . Levante o projeto e execute a URL abaixo no navegador:

            http://localhost:[porta]/swagger/index.html

    . Configurando o Scalar:

        . Caso queira adaptar o Scalar para a versão do .net9.0 em diante verifique os links abaixo:

            # A partir 20:40
            https://www.youtube.com/watch?v=Tx49o-5tkis&list=PL7yxJa4Na-ir9DLuPL_8kYhyHJXCoPyaR&index=4

            https://guides.scalar.com/scalar/scalar-api-references/net-integration

            https://medium.com/@encinecarlos/documentando-apis-net-com-scalar-2025bda7f39a

            https://carloscds.net/2024/06/aspnetcore-swagger-scalar/

        . Acesse o terminal e execute o comando abaixo na pasta raiz do projeto API:

            dotnet add package AspNetCore.Scalar --version 1.1.1

        . Acesse a classe "Program.cs" e insira as linhas abaixo:

            using AspNetCore.Scalar;                                    // Linha inserida

            var builder = WebApplication.CreateBuilder(args);

            // Add services to the container.

            builder.Services.AddControllers();

            builder.Services.AddEndpointsApiExplorer();         
            builder.Services.AddSwaggerGen();                   


            var app = builder.Build();

            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();                               
                app.UseSwaggerUI();   
            }

            // Bloco Inserido
            app.UseScalar(options =>
            {
                options.UseTheme(Theme.BluePlanet);
                options.UseLayout(Layout.Classic);

                options.RoutePrefix = "api-docs";

                options.DocumentTitle = "Documentação das APIs";
            });

            app.UseHttpsRedirection();

            app.UseAuthorization();

            app.MapControllers();

            app.Run();

        . Levante o projeto e execute a URL abaixo no navegador:

            http://localhost:[porta]/api-docs

    . Acesse o Postman e execute as APIs com os parâmetros abaixo:

        method: GET
        url: http://localhost:[porta]/api/people

        method: POST
        url: http://localhost:[porta]/api/people

    . Acesse a URL abaixo e execute as APIs do projeto:

        http://localhost:[porta]/api-docs    

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "4. Creating the PeopleController"


5. Adding required Nuget Package

    . Crie a branch "5. Adding required Nuget Package"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 5.AddingRequiredNugetPackage 

    . Na pasta raiz do projeto "webapi" execute os comandos abaixo:

        cd src/DotnetApiCompleteAuth

        dotnet add package Microsoft.EntityFrameworkCore --version 8.0.15

        dotnet add package Microsoft.EntityFrameworkCore.Tools --version 8.0.15

        dotnet add package Microsoft.EntityFrameworkCore.Design --version 8.0.15

        dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore --version 8.0.15

        dotnet add package Pomelo.EntityFrameworkCore.MySql --version 8.0.3

        dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 8.0.15

        # Execute a linha abaixo caso o "dotnet-ef" não existir no ambiente
        dotnet tool install --global dotnet-ef --version 8.0.15

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "5. Adding required Nuget Package"


6. ConnectionString and Application User

    . Crie a branch "6.ConnectionStringAandApplicationUser"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 6.ConnectionStringAndApplicationUser


    . Verificar detalhes sobre o arquivo "AppSettings.[Development].json" na 
        "Aula 71. Configurações de Debug" do curso "Fundamentos ASP.NET 6 - Balta"

    . Acesse o arquivo "appsettings.Development.json" e insira as linhas abaixo?

        {
            "Logging": {
                "LogLevel": {
                "Default": "Information",
                "Microsoft.AspNetCore": "Warning"
                }
            },
            "ConnectionStrings": {
                "default": "server=localhost; port=3003; database=dotnetdb; uid=root; pwd=root; Persist Security Info=false; Connect Timeout=300;SSL Mode=None; AllowPublicKeyRetrieval=True;"

            }
        }


    . Crie a pasta "Models" e dentro dela a classe "ApplicationUser" como abaixo:


        using Microsoft.AspNetCore.Identity;

        namespace DotnetApiCompleteAuth.Models;

        public class ApplicationUser : IdentityUser
        {
            public string Name { get; set; } = string.Empty;
        }

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "6. ConnectionString and Application User"

7. AppDbContext and Sending Data

    . Crie a branch "7.AppDbContextAndSendingData"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 7.AppDbContextAndSendingData

    . Crie a classe "AppDbContext" dentro da pasta "Models" com o conteúdo abaixo:

        using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
        using Microsoft.EntityFrameworkCore;

        namespace DotnetApiCompleteAuth.Models;

        public class AppDbContext : IdentityDbContext<ApplicationUser>
        {
            public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
            {

            }

        }

    . Acesse a classe "Programs.cs" e insira as linhas abaixo:

        using AspNetCore.Scalar;
        using DotnetApiCompleteAuth.Models;     // linha inserida
        using Microsoft.AspNetCore.Identity;    // linha inserida
        using Microsoft.EntityFrameworkCore;    // linha inserida

        ...
        builder.Services.AddControllers();

        // linha inserida
        string connectionString = builder.Configuration.GetConnectionString("default");

        // linha inserida
        builder.Services.AddDbContext<AppDbContext>(options =>
            options.UseMySql(connectionString, ServerVersion.AutoDetect(connectionString)));

        // linha inserida
        builder.Services.AddIdentity<ApplicationUser, IdentityRole>()
                        .AddEntityFrameworkStores<AppDbContext>()
                        .AddDefaultTokenProviders();

    . Crie a pasta "Constants" na pasta raiz do projeto API e crie a classe "Roles" com o conteúdo abaixo:

        namespace DotnetApiCompleteAuth.Constants;

        public static class Roles
        {
            public const string Admin = "Admin";
            public const string User = "User";
        }

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "7. AppDbContext and Sending Data"

8. Creating An Admin Account

    . Crie a branch "8.CreatingAnAdminAccount"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 8.CreatingAnAdminAccount


    . Crie a pasta "Data" e dentro dela a classe "DbSeeder" com o conteúdo abaixo:


        using DotnetApiCompleteAuth.Constants;
        using DotnetApiCompleteAuth.Models;
        using Microsoft.AspNetCore.Identity;
        using Microsoft.EntityFrameworkCore;

        namespace DotnetApiCompleteAuth.Data;

        public class DbSeeder
        {
            public static async Task SeedDataAsync(IApplicationBuilder app)
            {
                // Normalmente utilizamos injeção de dependência para criar os objetos
                // Porém, utilizaremos o objeto "scope" para essa finalidade
                using var scope = app.ApplicationServices.CreateScope();

                // Applying the pending migration (Not reccomended for prduction)
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();

                if ((await dbContext.Database.GetPendingMigrationsAsync()).Count() > 0)
                {
                    await dbContext.Database.MigrateAsync();
                }

                var logger = scope.ServiceProvider.GetRequiredService<ILogger<DbSeeder>>();

                try
                {
                    var userManager = scope.ServiceProvider.GetRequiredService<UserManager<ApplicationUser>>();

                    var roleManager = scope.ServiceProvider.GetRequiredService<RoleManager<IdentityRole>>();

                    // check if any user exists
                    if (!userManager.Users.Any())
                    {
                        // We will create a default user with role=Admin
                        var user = new ApplicationUser
                        {
                            Name = "Admin",
                            UserName = "admin@example.com",
                            Email = "admin@example.com",
                            EmailConfirmed = true,
                            SecurityStamp = Guid.NewGuid().ToString()
                        };

                        // create an Admin role if does not exists

                        if (!await roleManager.RoleExistsAsync(Roles.Admin))
                        {
                            var roleResult = await roleManager.CreateAsync(new IdentityRole(Roles.Admin));

                            if (roleResult.Succeeded == false)
                            {
                                var roleErrors = roleResult.Errors.Select(e => e.Description);
                                logger.LogError($"Failed to create admin role. Errors : {string.Join(",", roleErrors)}");
                                return;
                            }
                            logger.LogInformation("Admin role is created");
                        }

                        // Attempt to create admin user
                        var createUserResult = await userManager
                            .CreateAsync(user: user, password: "Admin@123");

                        // Validate user creation
                        if (createUserResult.Succeeded == false)
                        {
                            var errors = createUserResult.Errors.Select(e => e.Description);
                            logger.LogError(
                                $"Failed to create admin user. Errors: {string.Join(", ", errors)}"
                            );
                            return;
                        }

                        // adding role to user
                        var addUserToRoleResult = await userManager
                                        .AddToRoleAsync(user: user, role: Roles.Admin);

                        if (addUserToRoleResult.Succeeded == false)
                        {
                            var errors = addUserToRoleResult.Errors.Select(e => e.Description);
                            logger.LogError($"Failed to add admin role to user. Errors : {string.Join(",", errors)}");
                        }
                        logger.LogInformation("Admin user is created");
                    }

                }
                catch (Exception ex)
                {
                    logger.LogError(ex.Message);
                }
            }
        }

    . Altere a classe "Program.cs" com o conteúdo abaixo:

        using DotnetApiCompleteAuth.Data;       // Linha inserida

        ...
        app.UseHttpsRedirection();

        app.UseAuthorization();

        app.MapControllers();

        // Linha inserida
        await DbSeeder.SeedDataAsync(app);

        app.Run();

    . Acesse o prompt e execute o comando abaixo na pasta do projeto de APIs
 

        cd src/DotnetApiCompleteAuth

        # ATENÇÃO: Verifique se o container DOCKER do MySQL está levantado
        dotnet ef migrations add InitialCreate

        dotnet ef database update --context AppDbContext

    . Acesse a pasta "Migrations" e verifique se foi criado os arquivos de migração.

    . Levante o container do MySQL e execute o projeto de APIs com o comando abaixo:

        dotnet run

    . Acesse o MySQL e veja se foi criado o database do projeto com as tabelas 
        de controle de autorização devidamente populadas.

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "8. Creating An Admin Account"


9. Signup

    . Crie a branch "9.Signup"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 9.Signup

    . Crie a classe "SignupModel" na pasta "Model" com o conteúdo abaixo:

        using System.ComponentModel.DataAnnotations;

        namespace DotnetApiCompleteAuth.Models;

        public class SignupModel
        {
            [Required]
            [MaxLength(30)]
            public string Name { get; set; } = string.Empty;

            [Required]
            [MaxLength(30)]
            [EmailAddress]
            public string Email { get; set; } = string.Empty;

            [Required]
            [MaxLength(30)]
            public string Password { get; set; } = string.Empty;

        }


    . Crie a classe "AccountController" dentro da pasta "Controllers" com o conteúdo abaixo:

        using Microsoft.AspNetCore.Identity;
        using DotnetApiCompleteAuth.Models;
        using Microsoft.AspNetCore.Mvc;
        using DotnetApiCompleteAuth.Constants;

        namespace DotnetApiCompleteAuth.Controllers
        {
            [Route("api/[controller]")]
            [ApiController]
            public class AccountsController : ControllerBase
            {
                private readonly UserManager<ApplicationUser> _userManager;
                private readonly RoleManager<IdentityRole> _roleManager;
                private readonly ILogger<AccountsController> _logger;

                /****
                    A injeção de dependência da classe UserManager<ApplicationUser> pelo 
                    construtor do controller "AccountsController" foi configurada 
                    automaticamente pelo ASP.NET Core Identity 
                    quando adicionamos o seguinte código no método de configuração 
                    de serviços (geralmente em Program.cs):

                    // ...existing code...
                    builder.Services.AddIdentity<ApplicationUser, IdentityRole>()
                        .AddEntityFrameworkStores<AppDbContext>()
                        .AddDefaultTokenProviders();
                    // ...existing code...

                    Esse trecho de código no "Program.cs" registra todos os serviços
                    necessários de autenticação e gerenciamento de usuário no contêiner
                    de injeção de dependência.

                    Basta declarar o "UserManager<ApplicationUser> userManager" para que
                    seja feita a injeção de dependência. O mesmo se aplica para 
                    "RoleManager<IdentityRole> roleManager"

                ****/                

                public AccountsController(UserManager<ApplicationUser> userManager, RoleManager<IdentityRole> roleManager, ILogger<AccountsController> logger)
                {
                    _userManager = userManager;
                    _roleManager = roleManager;
                    _logger = logger;
                }

                [HttpPost("signup")]
                public async Task<IActionResult> Signup(SignupModel model)
                {
                    try
                    {
                        var existingUser = await _userManager.FindByNameAsync(model.Email);

                        if (existingUser != null)
                        {
                            return BadRequest("User already exists");
                        }

                        // Create User role if it doesn't exist
                        if ((await _roleManager.RoleExistsAsync(Roles.User)) == false)
                        {
                            var roleResult = await _roleManager
                                .CreateAsync(new IdentityRole(Roles.User));

                            if (roleResult.Succeeded == false)
                            {
                                var roleErros = roleResult.Errors.Select(e => e.Description);
                                _logger.LogError($"Failed to create user role. Errors : {string.Join(",", roleErros)}");
                                return BadRequest($"Failed to create user role. Errors : {string.Join(",", roleErros)}");
                            }
                        }

                        ApplicationUser user = new()
                        {
                            Email = model.Email,
                            SecurityStamp = Guid.NewGuid().ToString(),
                            UserName = model.Email,
                            Name = model.Name,
                            EmailConfirmed = true
                        };

                        // Attempt to create a user
                        var createUserResult = await _userManager.CreateAsync(user, model.Password);

                        // Validate user creation. If user is not created, log the error and
                        // return the BadRequest along with the errors
                        if (createUserResult.Succeeded == false)
                        {
                            var errors = createUserResult.Errors.Select(e => e.Description);
                            _logger.LogError(
                                $"Failed to create user. Errors: {string.Join(", ", errors)}"
                            );
                            return BadRequest($"Failed to create user. Errors: {string.Join(", ", errors)}");
                        }

                        // adding role to user
                        var addUserToRoleResult = await _userManager.AddToRoleAsync(user: user, role: Roles.User);

                        if (addUserToRoleResult.Succeeded == false)
                        {
                            var errors = addUserToRoleResult.Errors.Select(e => e.Description);
                            _logger.LogError($"Failed to add role to the user. Errors : {string.Join(",", errors)}");
                            return BadRequest($"Failed to create user Role. Errors: {string.Join(", ", errors)}");
                        }

                        return CreatedAtAction(nameof(Signup), null);

                    }
                    catch (Exception ex)
                    {
                        return StatusCode(StatusCodes.Status500InternalServerError, ex.Message);
                    }
                }
            }
        }

    . Levante o projeto:

        dotnet run

    . Acesse o Postman e execute a API abaixo:

        URL: http://localhost:[port]/api/accounts/signup
        Method: POST
        Body:   
            raw: JSON,
            {
            "name": "John Doe",
            "email": "john@example.com",
            "password": "John@123"

        }

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "9. Signup"

10. Login

    . Crie a branch "10.Login"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 10.Login


    . Crie a classe "LoginModel" na pasta "Models" com o conteúdo abaixo:

        using System.ComponentModel.DataAnnotations;

        namespace DotnetApiCompleteAuth.Models;

        public class LoginModel
        {
            [Required]
            public string Username { get; set; } = string.Empty;

            [Required]
            public string Password { get; set; } = string.Empty;
        }

    . Insira o trecho de código abaixo na classe "AccountsController.cs":


        ,,,
        [HttpPost("signup")]
        public async Task<IActionResult> Signup(SignupModel model)
        {
            ...
        }

        // Insira o método abaixo 
        [HttpPost("login")]
        public async Task<IActionResult> Login(LoginModel loginModel)
        {
            try
            {
                var user = await _userManager.FindByNameAsync(loginModel.Username);
                if (user == null ||
                    !await _userManager.CheckPasswordAsync(user, loginModel.Password)
                )
                {
                    return Unauthorized();
                }

                return Ok("Login successful");
            }
            catch (Exception ex)
            {
                return StatusCode(StatusCodes.Status500InternalServerError, ex.Message);
            }
        }
        ...

    . Acesse o Postman e execute a chamada de API abaixo:

        url: http://localhost:[port]/api/accounts/login
        method: POST
        raw: JSON
        Body: {
            "username": "john@example.com",
            "password": "John@123"
        }

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "10. Login"
 

11. JWT

    . Crie a branch "11.JWT"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 11.JWT

    . Crie a a pasta "ViewModels" e dentro dela a classe "ResultViewModel", responsável por padronizar e deixar mais amigável as mensagens de erro:

        using System.Collections.Generic;

        namespace DotnetApiCompleteAuth.ViewModels
        {
            public class ResultViewModel<T>
            {
                public ResultViewModel(T data, List<string> errors)
                {
                    Data = data;
                    Errors = errors;
                }

                public ResultViewModel(T data)
                {
                    Data = data;
                }

                public ResultViewModel(List<string> errors)
                {
                    Errors = errors;
                }

                public ResultViewModel(string error)
                {
                    Errors.Add(error);
                }

                public T Data { get; private set; }
                public List<string> Errors { get; private set; } = new();
            }
        }

    . Na raiz do projeto crie a classe "Settings":

        namespace DotnetApiCompleteAuth;

        public static class Settings
        {

            public static string ValidIssuer = "https://localhost:5232/";
            public static string ValidAudience = "https://localhost:5232/";
            public static string JwtKey = "ZmVkYWY3ZDg4NjNiNDhlMTk3YjkyODdkNDkyYjcwOGU=";

            public static string ApiKeyName = "api_key";
            public static string ApiKey = "curso_api_IlTevUM/z0ey3NwCV/unWg==";
            public static int TokenExpireIn = 600;
            public static int RefreshTokenExpireIn = 7200;
            public static string ExpireInUnit = "seconds";

        }

    . Crie a pasta "Services" e dentro dela a interface "ITokenService.cs" com o conteúdo abaixo:

        using System.Security.Claims;

        namespace DotnetApiCompleteAuth.Services;

        public interface ITokenService
        {
            string GenerateToken(IEnumerable<Claim> claims);
            string GenerateRefreshToken();
            ClaimsPrincipal GetPrincipalFromExpiredToken(string token);
        }

    . Crie a classe "TokenService.cs" dentro da pasta "Services" com o conteúdo abaixo:

        using System.IdentityModel.Tokens.Jwt;
        using System.Security.Claims;
        using System.Security.Cryptography;
        using System.Text;
        using Microsoft.IdentityModel.Tokens;

        namespace DotnetApiCompleteAuth.Services;

        public class TokenService : ITokenService
        {
            private readonly IConfiguration _configuration;

            //  Faz a injeção do objeto "appsettings.[Development].json"
            //                                  |
            //                                  V   
            public TokenService(IConfiguration configuration)
            {
                _configuration = configuration;     // Exemplo de uso: _configuration["JWT:ValidaUssuer"]
            }

            public string GenerateToken(IEnumerable<Claim> claims)
            {
                var tokenHandler = new JwtSecurityTokenHandler();

                // Create a symmetric security key using the secret key from the configuration.
                var authSigningKey = new SymmetricSecurityKey
                                (Encoding.UTF8.GetBytes(Settings.JwtKey));

                var tokenDescriptor = new SecurityTokenDescriptor
                {
                    Issuer = Settings.ValidIssuer,  
                    Audience = Settings.ValidAudience,
                    Subject = new ClaimsIdentity(claims),
                    NotBefore = DateTime.Now,
                    Expires = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                                                                        DateTime.Now.AddHours(Settings.TokenExpireIn),

                    SigningCredentials = new SigningCredentials
                                (authSigningKey, SecurityAlgorithms.HmacSha256)
                };

                var token = tokenHandler.CreateToken(tokenDescriptor);

                return tokenHandler.WriteToken(token);
            }

            public string GenerateRefreshToken()
            {
                throw new NotImplementedException();
            }

            public ClaimsPrincipal GetPrincipalFromExpiredToken(string token)
            {
                throw new NotImplementedException();
            }
        }


    . Insira a linha abaixo na classe "Program.cs":

        // Linha inserida
        using System.Text;

        // Linha inserida
        using DotnetApiCompleteAuth.Services;

        // Linha inserida
        using Microsoft.AspNetCore.Authentication.JwtBearer;

        // Linha inserida
        using Microsoft.IdentityModel.Tokens;

        ...

        // for identity
        builder.Services.AddIdentity<ApplicationUser, IdentityRole>()
                        .AddEntityFrameworkStores<AppDbContext>()
                        .AddDefaultTokenProviders();

        // ---> Linhas abaixo inseridas
        //
        // JWT Configuration
        // Authentication
        builder.Services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
        })
        .AddJwtBearer(options =>
        {
            options.SaveToken = true;
            options.RequireHttpsMetadata = false;
            options.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidateAudience = true,
                ValidAudience = Settings.ValidAudience,
                ValidIssuer = Settings.ValidIssuer,
                ClockSkew = TimeSpan.Zero,
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Settings.JwtKey))

            };
        });

        // ---> Linha inserida
        builder.Services.AddTransient<ITokenService, TokenService>()


        var app = builder.Build();
        app.UseHttpsRedirection();


        // ---> Linha inserida
        app.UseAuthentication();        

        app.UseAuthorization();

        app.MapControllers();
        ...

    . Funcionamento da "Claim" vs "Tokens":

        . No .NET, uma Claim (ou "declaração") é uma informação sobre um usuário, 
            como: nome, e-mail, permissões ou qualquer outro dado relevante para 
            autenticação e autorização. Cada claim é composta por um tipo 
            (por exemplo, ClaimTypes.Name ou ClaimTypes.Role) e um valor 
            (por exemplo, "joao@email.com" ou "Admin").

        . No contexto de autenticação com JWT (JSON Web Token), as claims são usadas 
            para armazenar informações do usuário dentro do próprio token. Assim, 
            quando um usuário faz login, você pode criar uma lista de claims representando 
            suas informações e permissões, e então gerar um token JWT que inclui 
            essas claims.

        . Como associar claims a um token:

            1. Criar as claims:

                . Você monta uma lista de claims com as informações desejadas, por exemplo:

                    List<Claim> authClaims = [
                        new (ClaimTypes.Name, user.UserName),
                        new (JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
                    ];


            2. Adicionar roles (funções) como claims:

                . Se o usuário tiver papéis (roles), você pode adicioná-los também:

                    foreach (var userRole in userRoles)
                    {
                        authClaims.Add(new Claim(ClaimTypes.Role, userRole));
                    }

            3. Gerar o token JWT com as claims:

                . Ao criar o token, você passa a lista de claims para o construtor do JWT:

                    var token = _tokenService.GenerateToken(authClaims);

        . Dessa forma, todas as informações relevantes sobre o usuário ficam dentro do token, 
            e podem ser lidas e validadas em cada requisição, sem necessidade de consultar 
            o banco de dados a todo momento. Isso é fundamental para autenticação e 
            autorização baseada em tokens no ASP.NET Core.

    . Insira as linhas abaixo na classe "AccountsController.cs"

        using Microsoft.AspNetCore.Identity;
        using DotnetApiCompleteAuth.Models;
        using Microsoft.AspNetCore.Mvc;
        using DotnetApiCompleteAuth.Constants;

        // Linha inserida
        using DotnetApiCompleteAuth.Services;

        // Linha inserida
        using System.Security.Claims;

        // Linha inserida
        using System.IdentityModel.Tokens.Jwt;

        // Linha inserida
        using System.Web;

        namespace DotnetApiCompleteAuth.Controllers
        {
            [Route("api/[controller]")]
            [ApiController]
            public class AccountsController : ControllerBase
            {
                private readonly UserManager<ApplicationUser> _userManager;
                private readonly RoleManager<IdentityRole> _roleManager;
                private readonly ILogger<AccountsController> _logger;

                // ----> Linha inserida
                private readonly ITokenService _tokenService;

                public AccountsController(UserManager<ApplicationUser> userManager, 
                                            RoleManager<IdentityRole> roleManager, 
                                            ILogger<AccountsController> logger,
                                            ITokenService tokenService)      // ----> Linha alterada
                {
                    _userManager = userManager;
                    _roleManager = roleManager;
                    _logger = logger;
                    _tokenService = tokenService;                            // Linha inserida
                }

                [HttpPost("login")]
                public async Task<IActionResult> Login(LoginModel loginModel)
                {
                    try
                    {
                        var user = await _userManager.FindByNameAsync(loginModel.Username);

                        if (user == null ||
                            !await _userManager.CheckPasswordAsync(user, loginModel.Password)
                        )
                        {
                            return Unauthorized();
                        }

        


                        // ----> Linhas abaixo inseridas
                        //
                        // creating the necessary claims
                        List<Claim> authClaims = [
                                new (ClaimTypes.Name, user.UserName),
                                new (JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
                        // unique id for token
                        ];

                        var userRoles = await _userManager.GetRolesAsync(user);

                        // adding roles to the claims. So that we can get the user role from the token.
                        foreach (var userRole in userRoles)
                        {
                            authClaims.Add(new Claim(ClaimTypes.Role, userRole));
                        }

                        // generating access token
                        var token = _tokenService.GenerateToken(authClaims);
                        
                        // ----> Fim da inserção





                        // ----> Linha alterada
                        // return Ok(new
                        // {
                        //     user = loginModel.Username,
                        //     tokenType = "Bearer",
                        //     token = HttpUtility.UrlDecode(token),
                        //     tokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                        //                                                                             DateTime.Now.AddHours(Settings.TokenExpireIn)
                        // });

                        return Ok(new ResultViewModel<dynamic>(new
                        {
                            user = loginModel.Username,
                            tokenType = "Bearer",
                            token = HttpUtility.UrlDecode(token),
                            tokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                                                                                                DateTime.Now.AddHours(Settings.TokenExpireIn)
                        }, null));

                    }
                    catch (Exception ex)
                    {
                        return StatusCode(StatusCodes.Status500InternalServerError, ex.Message);
                    }
                }


            }
        }

    . Acesse o Postman e execute a chamada de API abaixo:

        url: http://localhost:[port]/api/accounts/login
        method: POST
        raw: JSON
        Body: {
            "username": "john@example.com",
            "password": "John@123"
        }

    . Selecione o token criado e submeta ele no site e vejo as informações contidas no Payload dele:

        https://jwt.io

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "11. JWT"
 
12. Authenticating Our Routes

    . Crie a branch "12.AuthenticatingOurRoutes"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 12.AuthenticatingOurRoutes


    . Faça as alterações abaixo na classe "PeopleController.cs"

        using Microsoft.AspNetCore.Http;
        using Microsoft.AspNetCore.Mvc;
        using Microsoft.AspNetCore.Authorization;

        namespace DotnetApiCompleteAuth.Controllers;

        [Route("api/[controller]")]
        [ApiController]
        [Authorize]                                        // Linha inserida
        public class PeopleController : ControllerBase
        {
            [HttpGet]
            public IActionResult GetPeople()
            {
                return Ok("People data");
            }

            [HttpPost]
            public IActionResult CreatePerson()
            {
                return Ok("Person is created");
            }
        }


    . Acesse o Postman e execute as APIs com os parâmetros abaixo. Verifique se o acesso a API não foi permitido:

        method: GET
        url: http://localhost:[porta]/api/people

        method: POST
        url: http://localhost:[porta]/api/people


    . Faça as alterações abaixo na classe "PeopleController.cs"

        using Microsoft.AspNetCore.Http;
        using Microsoft.AspNetCore.Mvc;
        using Microsoft.AspNetCore.Authorization;

        namespace DotnetApiCompleteAuth.Controllers;

        [Route("api/[controller]")]
        [ApiController]
        [Authorize]                                     
        public class PeopleController : ControllerBase
        {
            [HttpGet]
            [AllowAnonymous]                            // Linha inserida
            public IActionResult GetPeople()
            {
                return Ok("People data");
            }

            [HttpPost]
            public IActionResult CreatePerson()
            {
                return Ok("Person is created");
            }
        }

    . Acesse o Postman e execute as APIs com os parâmetros abaixo. Verifique se o acesso a API foi permitido:

        method: GET
        url: http://localhost:[porta]/api/people


    . Acesse o Postman e execute a chamada de API abaixo:

        url: http://localhost:[port]/api/accounts/login
        method: POST
        raw: JSON
        Body: {
            "username": "john@example.com",
            "password": "John@123"
        }


    . Acesse o Postman e execute as APIs com os parâmetros abaixo. Verifique se o acesso a API foi permitido:

        method: POST
        Headers.Authorization: Bearer [Token obtido no item anterior]
        url: http://localhost:[porta]/api/people

    . Faça as alterações abaixo na classe "PeopleController.cs"

        using Microsoft.AspNetCore.Http;
        using Microsoft.AspNetCore.Mvc;
        using Microsoft.AspNetCore.Authorization;

        namespace DotnetApiCompleteAuth.Controllers;

        [Route("api/[controller]")]
        [ApiController]
        [Authorize( Roles = "Admin")]                       // Linha alterada
        public class PeopleController : ControllerBase
        {
            [HttpGet]
            [AllowAnonymous]                            
            public IActionResult GetPeople()
            {
                return Ok("People data");
            }

            [HttpPost]
            public IActionResult CreatePerson()
            {
                return Ok("Person is created");
            }
        }

    . Acesse o Postman e execute a chamada de API abaixo:

        url: http://localhost:[port]/api/accounts/login
        method: POST
        raw: JSON
        Body: {
            "username": "john@example.com",
            "password": "John@123"
        }


    . Acesse o Postman e execute as APIs com os parâmetros abaixo. Verifique se o acesso a API não foi permitido:

        method: POST
        Headers.Authorization: Bearer [Token obtido no item anterior]
        url: http://localhost:[porta]/api/people

    . Acesse o Postman e execute a chamada de API abaixo:

        url: http://localhost:[port]/api/accounts/login
        method: POST
        raw: JSON
        Body: {
            "username": "admin@example.com",
            "password": "Admin@123"
        }


    . Acesse o Postman e execute as APIs com os parâmetros abaixo. Verifique se o acesso a API foi permitido:

        method: POST
        Headers.Authorization: Bearer [Token obtido no item anterior]
        url: http://localhost:[porta]/api/people

    . O estado da sessão do token em APIs, especialmente quando se utiliza JWT (JSON Web Token), é stateless 
        (sem estado). Isso significa que o servidor não armazena informações sobre sessões de usuários 
        entre as requisições. Todas as informações necessárias para autenticação e autorização estão 
        contidas no próprio token, que é enviado pelo cliente (geralmente no header Authorization) a cada 
        requisição.

    . Como funciona:

        . O usuário faz login e recebe um token JWT, que contém claims com informações do usuário e permissões.

        . O cliente (frontend, mobile, etc.) armazena esse token (normalmente em memória, localStorage ou 
            cookies seguros).

        . Em cada requisição à API, o token é enviado no header Authorization.

        . O servidor valida o token (assinatura, expiração, claims) e, se válido, processa a requisição 
            sem precisar consultar o banco de dados para autenticação.

    . Melhores práticas para trabalhar com tokens em APIs:

        . Tokens curtos: Use tokens de acesso (access tokens) com tempo de expiração curto (ex: 15 minutos) 
            para reduzir riscos em caso de vazamento.
        
        . Refresh Tokens: Implemente refresh tokens para permitir que o usuário obtenha um novo access token 
            sem precisar fazer login novamente. O refresh token deve ter expiração maior e ser armazenado com 
            mais segurança.
        
        . Armazenamento seguro: Nunca armazene tokens em local inseguro (ex: localStorage em aplicações 
            web públicas). Prefira cookies HTTPOnly e Secure, ou armazenamento seguro em apps mobile.
        
        . HTTPS obrigatório: Sempre utilize HTTPS para proteger o tráfego dos tokens.
        
        . Revogação: Como o JWT é stateless, não há revogação nativa. Para casos críticos, mantenha uma 
            blacklist de tokens revogados ou use access tokens curtos e refresh tokens.
        
        . Validação: Sempre valide assinatura, expiração e claims do token em cada requisição.
        
        . Menor privilégio: Inclua apenas as informações necessárias nas claims do token, evitando 
            dados sensíveis.

    . Atualize a branch master

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git add .

        git commit -am "12. Authenticating Our Routes"
 


13. Refresh Tokens 

    . Crie a branch "13. Refresh Tokens"

        cd ~/workspace/dotnet/DotnetApiCompleteAuth

        git branch 13.RefreshTokens-Ravindra

        git branch 13.RefreshTokens-MySoltion

    . Refresh Token by Ravindra

        . Altere a branch para "13.RefreshTokens-Ravindra":

            git checkout 13.RefreshTokens-Ravindra

        . Insira as linhas abaixo na classe "TokenService.cs":

            using System.IdentityModel.Tokens.Jwt;
            using System.Security.Claims;
            using System.Security.Cryptography;
            using System.Text;
            using Microsoft.IdentityModel.Tokens;

            namespace DotnetApiCompleteAuth.Services;

            public class TokenService : ITokenService
            {

                public string GenerateToken(IEnumerable<Claim> claims)
                {
                    ...
                }

                // Linhas inseridas dentro do método
                public string GenerateRefreshToken()
                {
                    // Linha Eliminada
                    // throw new NotImplementedException();

                    // Create a 32-byte array to hold cryptographically secure random bytes
                    var randomNumber = new byte[32];

                    // Use a cryptographically secure random number generator
                    // to fill the byte array with random values
                    using var randomNumberGenerator = RandomNumberGenerator.Create();
                    randomNumberGenerator.GetBytes(randomNumber);

                    // Convert the random bytes to a base64 encoded string
                    return Convert.ToBase64String(randomNumber);                    
                }

                // Linhas inseridas dentro do método
                public ClaimsPrincipal GetPrincipalFromExpiredToken(string token)
                {
                    // Linha Eliminada
                    // throw new NotImplementedException();

                    // Define the token validation parameters used to validate the token.
                    var tokenValidationParameters = new TokenValidationParameters
                    {
                        ValidateIssuer = true,
                        ValidateAudience = true,
                        ValidAudience = Settings.ValidAudience,
                        ValidIssuer = Settings.ValidIssuer,
                        ValidateLifetime = false,
                        ClockSkew = TimeSpan.Zero,
                        IssuerSigningKey = new SymmetricSecurityKey
                        (Encoding.UTF8.GetBytes(Settings.JwtKey))
                    };

                    var tokenHandler = new JwtSecurityTokenHandler();

                    // Validate the token and extract the claims principal and the security token.
                    var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out SecurityToken securityToken);

                    // Cast the security token to a JwtSecurityToken for further validation.

                    var jwtSecurityToken  = securityToken as JwtSecurityToken;

                    // Ensure the token is a valid JWT and uses the HmacSha256 signing algorithm.
                    // If no throw new SecurityTokenException
                    if (jwtSecurityToken == null || !jwtSecurityToken.Header.Alg.Equals
                    (SecurityAlgorithms.HmacSha256, StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new SecurityTokenException("Invalid token");
                    }

                    // return the principal
                    return principal;
                }
            }

        . Crie a classe "TokenModel" dentro da pasta "Models" com o conteúdo abaixo:

            using System.ComponentModel.DataAnnotations;

            namespace DotnetApiCompleteAuth.Models;

            public class TokenModel
            {
                [Required]
                public string Token { get; set; } = string.Empty;

                [Required]
                public string RefreshToken { get; set; } = string.Empty;
            }

        . Crie a classe "TokenInfo" dentro da pasta "Models" com o conteúdo abaixo:

            using System;
            using System.ComponentModel.DataAnnotations;

            namespace DotnetApiCompleteAuth.Models;

            public class TokenInfo
            {
                public int Id { get; set; }

                [Required]
                [MaxLength(30)]
                public string Username { get; set; } = string.Empty;

                [Required]
                [MaxLength(200)]
                public string RefreshToken { get; set; } = string.Empty;

                [Required]
                public DateTime RefreshTokenExpireIn { get; set; }

                [Required]
                [DataType(DataType.Text)]
                public string Token { get; set; } = string.Empty;

                [Required]
                public DateTime TokenExpireIn { get; set; }
            }

        . Insira a linha abaixo na classe "AppDbContext.cs"

            using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
            using Microsoft.EntityFrameworkCore;

            namespace DotnetApiCompleteAuth.Models;

            public class AppDbContext : IdentityDbContext<ApplicationUser>
            {
                public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
                {

                }

                public DbSet<TokenInfo> TokenInfos{ get; set; }
            }

        . Acesse a raiz do projeto de APIs e execute o comando abaixo:

            cd src/DotnetApiCompleteAuth

            dotnet ef migrations add TokenInfos

            dotnet ef database update

        . Acesse a classe "AccountsController.cs" e insira as linhas abaixo:

            using Microsoft.AspNetCore.Identity;
            using DotnetApiCompleteAuth.Models;
            using Microsoft.AspNetCore.Mvc;
            using DotnetApiCompleteAuth.Constants;
            using DotnetApiCompleteAuth.Services;
            using System.Security.Claims;
            using System.IdentityModel.Tokens.Jwt;
            using System.Web;
            using DotnetApiCompleteAuth.ViewModels;
            using Microsoft.AspNetCore.Authorization;       // Linha inserida

            namespace DotnetApiCompleteAuth.Controllers
            {
                [Route("api/[controller]")]
                [ApiController]
                public class AccountsController : ControllerBase
                {
                    private readonly UserManager<ApplicationUser> _userManager;
                    private readonly RoleManager<IdentityRole> _roleManager;
                    private readonly ILogger<AccountsController> _logger;
                    private readonly ITokenService _tokenService;
                    private readonly AppDbContext _context;                     // Linha inserida

                    public AccountsController(UserManager<ApplicationUser> userManager,
                                                RoleManager<IdentityRole> roleManager,
                                                ILogger<AccountsController> logger,
                                                ITokenService tokenService,
                                                AppDbContext context)           // Linha inserida
                    {
                        _userManager = userManager;
                        _roleManager = roleManager;
                        _logger = logger;
                        _tokenService = tokenService;
                        _context = context;                                     // Linha inserida
                    }

                    .....

                    [HttpPost("login")]
                    [Produces("application/json")]
                    public async Task<IActionResult> Login(LoginModel loginModel)
                    {
                        try
                        {
                            ...

                            // generating access token
                            var token = _tokenService.GenerateToken(authClaims);


                            // Linhas Eliminadas
                            //
                            // return Ok(new
                            // {
                            //     user = loginModel.Username,
                            //     tokenType = "Bearer",
                            //     token = HttpUtility.UrlDecode(token),
                            //     tokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                            //                                                                             DateTime.Now.AddHours(Settings.TokenExpireIn)
                            // });


                            // Inicio da Inserção

                            var tokenInfo = _context.TokenInfos.FirstOrDefault(a => a.Username == user.UserName);

                            // If tokenInfo is null for the user, create a new one
                            if (tokenInfo == null)
                            {
                                var ti = new TokenInfo
                                {
                                    Username = user.UserName,
                                    Token = HttpUtility.UrlDecode(token),
                                    TokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                                                                                                    DateTime.Now.AddHours(Settings.TokenExpireIn),
                                    RefreshToken = _tokenService.GenerateRefreshToken(),
                                    RefreshTokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.RefreshTokenExpireIn) :
                                                                            DateTime.Now.AddHours(Settings.RefreshTokenExpireIn)
                                };
                                _context.TokenInfos.Add(ti);

                                tokenInfo = ti;
                            }
                            else 
                            {
                                tokenInfo.Token = HttpUtility.UrlDecode(token);
                                tokenInfo.TokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                                                                                                    DateTime.Now.AddHours(Settings.TokenExpireIn);
                                // If tokenInfo exists but is expired, update it
                                tokenInfo.RefreshToken = _tokenService.GenerateRefreshToken();
                                tokenInfo.RefreshTokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.RefreshTokenExpireIn) :
                                                                            DateTime.Now.AddHours(Settings.RefreshTokenExpireIn);
                            }

                            await _context.SaveChangesAsync();
                            
                            return Ok(new ResultViewModel<dynamic>(new
                            {
                                user = loginModel.Username,
                                tokenType = "Bearer",
                                token = HttpUtility.UrlDecode(token),
                                refreshToken = HttpUtility.UrlDecode(tokenInfo.RefreshToken),
                                tokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                                                                                                    DateTime.Now.AddHours(Settings.TokenExpireIn),
                                refreshTokenExpireIn = tokenInfo.RefreshTokenExpireIn
                            }, null));


                            // Fim da Inserção

                        }
                        catch (Exception ex)
                        {
                            return StatusCode(StatusCodes.Status500InternalServerError, ex.Message);
                        }
                    }




                    // Método "Refresh" Inserido

                    [HttpPost("token/refresh")]
                    public async Task<IActionResult> Refresh(TokenModel tokenModel)
                    {
                        try
                        {
                            var principal = _tokenService.GetPrincipalFromExpiredToken(tokenModel.Token);
                            var username = principal.Identity.Name;

                            var tokenInfo = _context.TokenInfos.SingleOrDefault(u => u.Username == username);

                            if (tokenInfo == null
                                || HttpUtility.UrlDecode(tokenInfo.RefreshToken) != tokenModel.RefreshToken
                                || tokenInfo.RefreshTokenExpireIn <= DateTime.Now
                                || HttpUtility.UrlDecode(tokenInfo.Token) != tokenModel.Token)
                            {
                                if (HttpUtility.UrlDecode(tokenInfo.RefreshToken) != tokenModel.RefreshToken
                                    || HttpUtility.UrlDecode(tokenInfo.Token) != tokenModel.Token)
                                {
                                    _logger.LogWarning("Invalid token/refreshToken");

                                    return BadRequest("Invalid token/refreshToken");
                                }
                                else 
                                {
                                    _logger.LogWarning("RefreshToken expired");

                                    return BadRequest("RefreshToken expired");
                                }
                            }

                            var newToken = _tokenService.GenerateToken(principal.Claims);
                            var newRefreshToken = _tokenService.GenerateRefreshToken();

                            tokenInfo.Token = HttpUtility.UrlDecode(newToken);
                            tokenInfo.TokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                                                                                                DateTime.Now.AddHours(Settings.TokenExpireIn);

                            if (tokenInfo.RefreshTokenExpireIn <= DateTime.Now)
                            {
                                tokenInfo.RefreshToken = HttpUtility.UrlDecode(newRefreshToken); // rotating the refresh token
                                tokenInfo.RefreshTokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.RefreshTokenExpireIn) :
                                                                                DateTime.Now.AddHours(Settings.RefreshTokenExpireIn);
                            }

                            await _context.SaveChangesAsync();

                            // return Ok(new TokenModel
                            // {
                            //     Token = newAccessToken,
                            //     RefreshToken = newRefreshToken
                            // });

                            return Ok(new ResultViewModel<dynamic>(new
                            {
                                user = username,
                                tokenType = "Bearer",
                                token = HttpUtility.UrlDecode(newToken),
                                refreshToken = HttpUtility.UrlDecode(tokenInfo.RefreshToken),
                                tokenExpireIn = Settings.ExpireInUnit.Equals("seconds") ? DateTime.Now.AddSeconds(Settings.TokenExpireIn) :
                                                                                                    DateTime.Now.AddHours(Settings.TokenExpireIn),
                                refreshTokenExpireIn = tokenInfo.RefreshTokenExpireIn
                            }, null));


                        }
                        catch (Exception ex)
                        {
                            _logger.LogError(ex.Message);
                            return StatusCode(StatusCodes.Status500InternalServerError);
                        }
                    }


                    // Método "Revoke" Inserido

                    [HttpPost("token/logout")]
                    [Authorize]
                    public async Task<IActionResult> Revoke()   // Deixa os token/refreshToken invalidos após o logout
                    {
                        try
                        {
                            var username = User.Identity.Name;

                            var userToken = _context.TokenInfos.SingleOrDefault(u => u.Username == username);
                            if (userToken == null)
                            {
                                return BadRequest();
                            }

                            userToken.RefreshTokenExpireIn = DateTime.MinValue;

                            await _context.SaveChangesAsync();

                            return Ok(true);
                        }
                        catch (Exception ex)
                        {
                            _logger.LogError(ex.Message);
                            return StatusCode(StatusCodes.Status500InternalServerError);
                        }
                    }
                }

            }        

        . Diminua o parâmetro de tempo de expiração, no arquivo "Settings.cs", do Token.

        . Acesse o Postman e execute a API de login para pegar o token:

            url: https://localhost:[port]/api/accounts/login
            method: POST
            Body: {
                raw: true,
                {
                    "username": "admin@example.com",
                    "password": "Admin@123"
                }

            }

        . Acesse o Postman e execute as APIs com os parâmetros abaixo. Verifique se o acesso a API foi permitido:

            url: http://localhost:[porta]/api/people
            method: POST
            Headers.Authorization: Bearer [Token obtido no item anterior]

        . Após a expiração do token, acesse a API de refresh token para obter um novo token.
            Detalhe, para testar com token, ou refreshToken, invalidos.

            url: http://localhost:[porta]/api/accounts/token/refresh
            method: POST
            body: {
                raw: true,
                {
                    "Token": [Token Invalido],
                    "refreshToken": [refreshToken Inválido]
                }
            }

        . Após a expiração do token, acesse a API de refresh token para obter um novo token:

            url: http://localhost:[porta]/api/accounts/token/refresh
            method: POST
            body: {
                raw: true,
                {
                    "token": [Token obtido no item anterior],
                    "refreshToken": [refreshToken obtido no item anterior]
                }
            }

        . Acesse o Postman e execute as APIs com os parâmetros abaixo. Verifique se o acesso a API foi permitido:

            url: http://localhost:[porta]/api/people
            method: POST
            Headers.Authorization: Bearer [Token obtido no item anterior]

        . Execute a API de logout

            url: http://localhost:[porta]/api/accounts/token/logout
            method: POST

        . Execute a API de RefreshToken. Verifique se a mensagem será: "Token Expired"

            url: http://localhost:[porta]/api/accounts/token/refresh
            method: POST
            body: {
                raw: true,
                {
                    "token": [Token obtido no item anterior],
                    "refreshToken": [refreshToken obtido no item anterior]
                }
            }






        . Atualize a branch "13.RefreshTokens-Ravindra"

            cd ~/workspace/dotnet/DotnetApiCompleteAuth

            git add .

            git commit -am "13.RefreshTokens-Ravindra"
       

1. Refazer as mudanças da aula 13. Refresh Token na branch 13.RefreshToken-MySolution2

59.04