https://github.com/balta-io/api-aspnet-5-ef-core-sqlite

Desenvolvimento de API com ASP.NET, EF Core e SQLite
====================================================

. Acesse a pasta de projetos e digite o comando abaixo:

    dotnet new webapi -o Contrato -n contrato -f net5.0

. Acesse a pasta do projeto criado com o VSCode e execute os comandos abaixo:

    dotnet add package Microsoft.EntityFrameworkCore --version 5.0.9        

    dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 5.0.9

    # Se for usar o banco de dados SQL Server execute a linha abaixo
    #
    # dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 5.0.9

    dotnet add package Microsoft.EntityFrameworkCore.Design --version 5.0.9

    # Execute a linha abaixo caso o "dotnet-ef" não existir no ambiente
    dotnet tool install --global dotnet-ef --version 5.0.17

. Apague as classes abaixo:

    WeatherForecast.cs
    Controllers/WeatherForecastController.cs

. Crie a pasta "Models" na raiz do projeto.

. Crie as classes abaixo:

    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.ComponentModel.DataAnnotations.Schema;
    using System.Linq;
    using System.Threading.Tasks;

    namespace contrato.Models
    {

        [Table("cliente")]
        public class Cliente
        {
            [Key]
            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
            [Column("codigo")]
            public int codigo { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [Column("cpf", TypeName ="VARCHAR(15)")]
            public string cpf { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [MaxLength(150, ErrorMessage = "Este campo deve ter entre 5 a 150 caracateres")]
            [MinLength(5, ErrorMessage = "Este campo dever ter entre 5 a 150 caracateres")]
            [Column("nome", TypeName ="VARCHAR(100)")]
            public string nome { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [Column("dataNascimento", TypeName ="DATE")]
            public DateTime? dataNascimento { get; set; }

            [Column("rg", TypeName ="VARCHAR(11)")]
            public string rg { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [Column("sexo", TypeName ="CHAR(1)")]
            public string sexo { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [Column("estadoCivil", TypeName ="VARCHAR(10)")]
            public string estadoCivil { get; set; }

            [Column("pai", TypeName ="VARCHAR(100)")]
            public string pai { get; set; }

            [Column("mae", TypeName ="VARCHAR(100)")]
            public string mae { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [MaxLength(250, ErrorMessage = "Este campo deve ter entre 5 a 150 caracateres")]
            [MinLength(5, ErrorMessage = "Este campo deve ter entre 5 a 150 caracateres")]
            [Column("endereco", TypeName ="VARCHAR(100)")]
            public string endereco { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [MaxLength(100, ErrorMessage = "Este campo deve ter entre 5 a 100 caracateres")]
            [MinLength(5, ErrorMessage = "Este campo deve ter entre 5 a 100 caracateres")]
            [Column("cidade", TypeName ="VARCHAR(50)")]
            public string cidade { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [MaxLength(2, ErrorMessage = "Este campo deve ter 2 caracateres")]
            [MinLength(2, ErrorMessage = "Este campo deve ter 2caracateres")]
            [Column("estado", TypeName ="CHAR(2)")]
            public string estado { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [Column("cep", TypeName ="CHAR(8)")]
            public string cep { get; set; }

            [Required(ErrorMessage = "Este campo é obrigatorio")]
            [Column("telefone", TypeName ="VARCHAR(20)")]
            public string telefone { get; set; }

            [Column("dataInclusao", TypeName ="DATE")]
            public DateTime dataInclusao { get; set; } = new DateTime();
        }
    }

. Acesse os arquivos "appsettings.json" e "appsettings.Development.json" e insira a linha abaixo:

    {
        "ConnectionStrings": {              
            "DefaultConnection": "DataSource=app.db;Cache=Shared"
        },
        ...
    }

    . IMPORTANTE: As configurações de "Development" existentes nos "Properties/launchSetting.json" não está apontando
                    para o arquivo "appsetings.Development.json", talvez isto ocorra devido ao comando "dotnet ef migrations..."
                    enxergar somente o arquivo "appsetings.json"

. Acrescente a linha abaixo no arquivo "Startup.cs":

    ...
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            var connectionStrings = Configuration.GetConnectionString("DefaultConnection");     // Linha inserida

            services.AddDbContext<AppDbContext>(options =>                                      // Linha inserida
                options.UseSqlite(connectionStrings));
        }
        ...
    }

. Crie a pasta "Data" dentro da raiz do projeto e dentro dela crie a classe abaixo:

    using System;
    using contrato.Models;
    using Microsoft.EntityFrameworkCore;

    namespace contrato.Data
    {
        public class AppDbContext: DbContext
        {
            public AppDbContext(DbContextOptions<AppDbContext> options ) : base(options)
            {
            }

//            protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) 
//                        => optionsBuilder.UseSqlite();
            protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            {
                optionsBuilder.UseSqlite();
                optionsBuilder.LogTo( Console.WriteLine );
            }

            public DbSet<Cliente> Clientes { get; set; }
        }
    }

. Na raiz do projeto execute os comandos abaixo:

    dotnet clean

    dotnet build

    dotnet ef migrations add InitialCreation

    dotnet ef database update

. Atualize a estrutura do projeto, verifique se o arquivo do SqLite "app.db" foi criado com sucesso,
    instale alguma extensão do SqLite no VSCode para executar instruções DMLs e faça a consulta da 
    estrutura do banco nele.

. Crie a pasta "ViewModels" e insira as classes abaixo :

    . Classe "ClienteViewModel", responsável por receber os parâmetros vindos do corpo da chamada para 
        dentro da assinatura do método da rota:

        namespace contrato.ViewModels
        {
            public class ClienteViewModel
            {
                public string cpf { get; set; }
                public string nome { get; set; }
            }
        }

    . Classe "CreateClienteViewModel"responsável por receber os parâmetros vindos do corpo da chamada para 
        dentro da assinatura do método da rota; preparada para ser utilizada na validação do model:

        using System;
        using System.ComponentModel.DataAnnotations;

        namespace contrato.ViewModels
        {
            public class CreateClienteViewModel
            {
                public int Codigo { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                public string cpf { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                [MaxLength(150, ErrorMessage = "Este campo deve ter entre 5 a 150 caracateres")]
                [MinLength(5, ErrorMessage = "Este campo dever ter entre 5 a 150 caracateres")]
                public string nome { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                public DateTime? dataNascimento { get; set; }

                public string rg { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                public string sexo { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                public string estadoCivil { get; set; }

                public string pai { get; set; }

                public string mae { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                [MaxLength(250, ErrorMessage = "Este campo deve ter entre 5 a 150 caracateres")]
                [MinLength(5, ErrorMessage = "Este campo deve ter entre 5 a 150 caracateres")]
                public string endereco { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                [MaxLength(100, ErrorMessage = "Este campo deve ter entre 5 a 100 caracateres")]
                [MinLength(5, ErrorMessage = "Este campo deve ter entre 5 a 100 caracateres")]
                public string cidade { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                [MaxLength(2, ErrorMessage = "Este campo deve ter 2 caracateres")]
                [MinLength(2, ErrorMessage = "Este campo deve ter 2caracateres")]
                public string estado { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                public string cep { get; set; }

                [Required(ErrorMessage = "Este campo é obrigatorio")]
                public string telefone { get; set; }

                public DateTime dataInclusao { get; set; } = new DateTime();
            }
        }

    . Classe "ResultViewModel", responsável por padronizar e deixar mais amigável as mensagens de erro:

        using System.Collections.Generic;

        namespace contrato.ViewModels
        {
            public class ResultViewModel<T>
            {
                public ResultViewModel(T data, List<string> errors)
                {
                    Data = data;
                    Errors = errors;
                }

                public ResultViewModel(T data)
                {
                    Data = data;
                }

                public ResultViewModel(List<string> errors)
                {
                    Errors = errors;
                }

                public ResultViewModel(string error)
                {
                    Errors.Add(error);
                }

                public T Data { get; private set; }
                public List<string> Errors { get; private set; } = new();
            }
        }

. Crie a pasta "Extensions" e inclua a classe abaixo:

    using System.Collections.Generic;
    using System.Linq;
    using Microsoft.AspNetCore.Mvc.ModelBinding;

    namespace contrato.Extensions
    {
        public static class ModelStateExtension
        {
            public static List<string> GetErrors(this ModelStateDictionary modelState)
            {
                var result = new List<string>();
                foreach (var item in modelState.Values)
                    result.AddRange(item.Errors.Select(error => error.ErrorMessage));

                return result;
            }
        }
    }

. Acesse a classe "Startup.cs" e faça as alterações abaixo:

    ...
    public void ConfigureServices(IServiceCollection services)
    {
        ...

        // Ao fazer a configuração ".ConfigureApiBehaviorOptions", somos obrigados validar manualmente dentro dos controllers os models através 
        // do método "ModelState.IsValid".
        // Esta configuração trabalhará em conjunto classes "ResultViewModel" e "ModelStateExtension".
        //
        // Exemplo:     return BadRequest(new ResultViewModel<Category>(ModelState.GetErrors())); 
        //
        services.AddControllers()
                .ConfigureApiBehaviorOptions(options =>        
                                            {                                                       
                                                options.SuppressModelStateInvalidFilter = true;     
                                            });            
        ...
    }
    ...

. Acesse a pasta "Controllers"  crie a classe abaixo:


https://www.macoratti.net/19/08/aspnc_restrota1.htm


    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using contrato.Data;
    using contrato.Extensions;
    using contrato.Models;
    using contrato.ViewModels;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.EntityFrameworkCore;

    namespace contrato.Controllers
    {
        [ApiController]
        [Route("[controller]")]
        public class ClienteController : ControllerBase
        {

            [HttpGet("v1")]
            public async Task<ActionResult<List<Cliente>>> GetAsync([FromServices] AppDbContext context)
            {
                try
                {
                    var clientes = await context.Clientes
                                                .AsNoTracking()
                                                .ToListAsync();

                    return Ok(new ResultViewModel<List<Cliente>>(clientes));
                }
                catch (Exception ex)
                {
                    return StatusCode(500, new ResultViewModel<List<Cliente>>($"Ocorreu o seguinte erro [ {ex.Message} ]"));
                }

            }

            [HttpPost("v1")]
            public async Task<ActionResult<Cliente>> PostAsync([FromServices] AppDbContext context,
                                                                    [FromBody] CreateClienteViewModel model)
            {
                if (!ModelState.IsValid)
                    return BadRequest(new ResultViewModel<Cliente>(ModelState.GetErrors()));

                var cliente = new Cliente
                {
                    cpf = model.cpf,
                    nome = model.nome,
                    dataNascimento = model.dataNascimento,
                    rg = model.rg,
                    sexo = model.sexo,
                    estadoCivil = model.estadoCivil,
                    pai = model.pai,
                    mae = model.mae,
                    endereco = model.endereco,
                    cidade = model.cidade,
                    estado = model.estado,
                    cep = model.cep,
                    telefone = model.telefone,
                    dataInclusao = DateTime.Now
                };

                try
                {
                    await context.Clientes.AddAsync(cliente);
                    await context.SaveChangesAsync();

                    var createdResource = new { Id = 1, Version = "1.0" };

                    // Uri uri = new Uri($"https://localhost:5001/cliente/v1/cpf/{model.cpf}");

                    // return Created(uri, model);
                    return Created($"cliente/v1/cpf/{model.cpf}", new ResultViewModel<Cliente>(cliente));
                }
                catch (Exception ex)
                {
                    return StatusCode(500, new ResultViewModel<Cliente>($"Ocorreu o seguinte erro [ {ex.Message} ]"));  // Linha alterada
                }

                // https://ochzhen.com/blog/created-createdataction-createdatroute-methods-explained-aspnet-core
                // https://www.macoratti.net/19/06/aspnc_3dwebapi1.htm
                // https://code-maze.com/net-core-web-development-part6/
            }

            [HttpGet("v1/cpf/{cpf}")]
            // [HttpGet("{cpf:regex(^\\d{{3}}.\\d{{3}}.\\d{{3}}-\\d{{2}}$)}")]
            public async Task<ActionResult<Cliente>> GetByCpf([FromServices] AppDbContext context,
                                                                [FromRoute] string cpf)
            {

                try
                {
                    var cliente = await context.Clientes
                                            .AsNoTracking()
                                            .FirstOrDefaultAsync(x => x.cpf == cpf);

                    return cliente == null ?
                                    NotFound(new { Id = 1, error = $"Não foi encontrado cliente com o cpf {cpf}" }) :
                                    Ok(new ResultViewModel<Cliente>(cliente));
                }
                catch (Exception ex)
                {
                    return StatusCode(500, new ResultViewModel<List<Cliente>>($"Ocorreu o seguinte erro [ {ex.Message} ]"));
                }

            }

            [HttpGet("v1/cpf")]
            public async Task<ActionResult<Cliente>> GetByCpfForBody([FromServices] AppDbContext context,
                                                                        [FromBody] ClienteViewModel viewModel)
            {

                try
                {
                    var cliente = await context.Clientes
                                            .AsNoTracking()
                                            .FirstOrDefaultAsync(x => x.cpf == viewModel.cpf);

                    return cliente == null ?
                                    NotFound(new { Id = 1, error = $"Não foi encontrado cliente com o cpf {viewModel.cpf}" }) :
                                    Ok(new ResultViewModel<Cliente>(cliente));
                }
                catch (Exception ex)
                {
                    return StatusCode(500, new ResultViewModel<List<Cliente>>($"Ocorreu o seguinte erro [ {ex.Message} ]"));
                }

            }

            [HttpGet("v1/nome")]
            public async Task<ActionResult<List<Cliente>>> GetByName([FromServices] AppDbContext context,
                                                                        [FromBody] ClienteViewModel viewModel)
            {
                var clientes = await context.Clientes
                                    .AsNoTracking()
                                    .Where(x => x.nome.ToUpper().Contains(viewModel.nome.ToUpper()))
                                    .ToListAsync();

                return clientes == null ?
                                NotFound(new ResultViewModel<Cliente>("Cliente não encontrado")) :
                                Ok(new ResultViewModel<List<Cliente>>(clientes));
            }

            [HttpGet("v1/nome/{nome}")]
            public async Task<ActionResult<List<Cliente>>> GetByName([FromServices] AppDbContext context,
                                                                        [FromRoute] string nome)
            {
                var clientes = await context.Clientes
                                    .AsNoTracking()
                                    .Where(x => x.nome.ToUpper().Contains(nome.ToUpper()))
                                    .ToListAsync();

                return clientes == null ?
                                NotFound(new ResultViewModel<Cliente>("Cliente não encontrado")) :
                                Ok(new ResultViewModel<List<Cliente>>(clientes));
            }

            [HttpPut("v1/{cpf}")]
            public async Task<ActionResult<Cliente>> Put([FromServices] AppDbContext context,
                                                            [FromBody] CreateClienteViewModel model,
                                                            [FromRoute] string cpf)
            {
                if (!ModelState.IsValid)
                    return BadRequest(new ResultViewModel<Cliente>(ModelState.GetErrors()));

                try
                {
                    var cliente = await context.Clientes
                                            .AsNoTracking()
                                            .FirstOrDefaultAsync(x => x.cpf == cpf);

                    if (cliente == null)
                        return NotFound(new ResultViewModel<Cliente>("Cliente não encontrado"));


                    cliente.cpf = model.cpf;
                    cliente.nome = model.nome;
                    cliente.dataNascimento = model.dataNascimento;
                    cliente.rg = model.rg;
                    cliente.sexo = model.sexo;
                    cliente.estadoCivil = model.estadoCivil;
                    cliente.pai = model.pai;
                    cliente.mae = model.mae;
                    cliente.endereco = model.endereco;
                    cliente.cidade = model.cidade;
                    cliente.estado = model.estado;
                    cliente.cep = model.cep;
                    cliente.telefone = model.telefone;
                    cliente.dataInclusao = DateTime.Now;

                    context.Clientes.Update(cliente);
                    await context.SaveChangesAsync();

                    return StatusCode(201, cliente);
                }
                catch (Exception ex)
                {
                    return BadRequest(new ResultViewModel<Cliente>(ex.Message));
                }
            }

            [HttpDelete("v1/{cpf}")]
            public async Task<ActionResult> Delete([FromServices] AppDbContext context,
                                        string cpf)
            {
                try
                {
                    var cliente = context.Clientes
                                    .AsNoTracking()
                                    .Where(x => x.cpf == cpf)
                                    .FirstOrDefault();

                    if (cliente == null)
                        return NotFound(new ResultViewModel<Cliente>("Cliente não encontrado"));

                    context.Clientes.Remove(cliente);

                    await context.SaveChangesAsync();

                    return NoContent();
                }
                catch (Exception ex)
                {
                    return BadRequest(new ResultViewModel<Cliente>(ex.Message));
                }
            }
        }
    }

    . Acesse a aula "Aula 36.  Padronizando erros" do curso "Fundamentos ASP.NET 6" e veja mais detalhes sobre 
        configurações para deixar a validação manual dentro dos controllers dos models através 
        do método "ModelState.IsValid":

            ...
            if (!ModelState.IsValid)                        
                return BadRequest(new ResultViewModel<Category>(ModelState.GetErrors()));
            ...


. Execute a aplicacao com o comando abaixo:

    dotnet build

    dotnet watch run

. Acesse o Postman e execute as URLs com os parâmetros abaixo:

    Method: POST
    URL: https://localhost:5001/cliente/v1
    Body.raw: 
                {
                    "cpf": "018.020.098-41",
                    "nome": "MARCIO VENEZIANO",
                    "dataNascimento": "1960-08-11T00:00:00",
                    "rg": "298655913",
                    "sexo": "M",
                    "estadoCivil": "OUTROS",
                    "pai": "ARTHUR VENEZIANO",
                    "mae": "BENEDITA DE OLIVEIRA",
                    "endereco": "R TAMBAU ",
                    "cidade": "GUARUJA",
                    "estado": "SP",
                    "cep": "11451170",
                    "telefone": "13 30174206"
                }    
    JSON:   true

    Method: GET
    URL: https://localhost:5001/cliente/v1
    Body.none

    Method: GET
    URL: https://localhost:5001/cliente/v1/cpf/049.045.238-81
    Body.None: True

    Method: GET
    URL: https://localhost:5001/cliente/v1/cpf
    Body.raw: { "cpf": "049.045.238-81"}

    Method: GET
    URL: https://localhost:5001/cliente/v1/nome
    Body.raw: { "nome": "MARCO" }

    Method: PUT
    URL: https://localhost:5001/cliente/v1
    Body.raw:     {
                    "codigo": "317282",
                    "cpf": "106.523.608-60",
                    "nome": "MARCO A DA SILVA",
                    "dataNascimento": "1966-10-17T00:00:00",
                    "rg": "16531421",
                    "sexo": "M",
                    "estadoCivil": "CASADO",
                    "pai": "LOURIVAL MARINHO SILVA",
                    "mae": "BENEDITA ABRANTES SILVA",
                    "endereco": "R CARIOBA 360 ",
                    "cidade": "SÃO PAULO",
                    "estado": "SP",
                    "cep": "02423100",
                    "telefone": "11 9 8336-1336"
                }

    Method: DELETE
    URL: https://localhost:5001/v1/clientes/106.523.608-58
    Body.None: true


Adicionando Paginação
---------------------

. Altere o método "GetAsyncPage" como abaixo:

    [HttpGet("v1/pageable")]
        public async Task<ActionResult<List<Cliente>>> GetAsyncPage([FromServices] AppDbContext context,
                                                                    [FromQuery] int page = 0,               // Linha inserida
                                                                    [FromQuery] int pageSize = 25,          // Linha inserida
                                                                    [FromQuery] string orderBy = "cpf")     // Linha inserida
    {
        try
        {
            var count = await context.Clientes.AsNoTracking().CountAsync();    // Linha inserida

            var clientes = await context.Clientes                                                       // Linha alterada
                                        .AsNoTracking()
                                        .Skip(page * pageSize)
                                        .Take(pageSize)
                                        .OrderBy(x => ( orderBy == "cpf"? x.cpf: x.nome ))
                                        .ToListAsync();

            return Ok(new ResultViewModel<dynamic>(new
            {
                totalItem = count,
                totalPage = Math.Floor( (float) (count / pageSize)),
                currentPage = page,
                pageSize,
                clientes
            }));
        }
        catch ( Exception ex)
        {
            return StatusCode(500, new ResultViewModel<List<Cliente>>($"Ocorreu o seguinte erro [ {ex.Message} ]"));
        }

    }

. Execute os comandos abaixo no banco de dados:

    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (53,'570.097.758-34','SELMA MARIA SPINOLA GOMES','1952-04-19','5.563.343-2','F','DIVORCIADO','RENATO PEREIRA GOMES','AIDA SPINOLA GOMES','RUA BRIGADEIRO GAMA BARCELOS','SÃO PAULO','SP','04355070','11 50347366', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (181,'090.568.028-60','ALBA DE OLIVEIRA GASPAR','1938-07-23','12253495-5','F','VIUVO','AGUINALDO COSTA','FRANCELINA SANTOS COSTA','RUA GOIAS','PERUIBE','SP','11750000','13 34552725', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (311,'619.909.498-00','MARCIA SUELY CAPUTO LIMA','1950-04-06','52380786','F','SOLTEIRO','EOLO  LIMA','MARIA ZELIA CAPUTO LIMA','Avenida Braz Leme','São Paulo','SP','02022020','11 29590294', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (737,'127.074.818-15','ADEMAR BRASILIO PANARIELO','1941-03-19','19411108','M','CASADO','BRASILIO PANARIELO','MARIA  ALICE PANARIELO','Avenida dos Bancários','Santos','SP','11030301','13 32381745', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (874,'049.045.238-81','VILSON BORGES LUZ','1963-12-15','15535397-4','M','COMPANHEIRO','VALDELINO SILVA LUZ','MARIA DAS DORES BORGES LUZ','Praça Tenente Mauro Batista de Miranda','Santos','SP','11013360','13 34680638', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (1110,'050.391.628-55','VALDEMIR MENEZES DA SILVA','1964-05-25','20.876.169-X','M','CASADO','VALTER FERREIRA DA SILVA','MARIA DE LOURDES MENEZES DA SILVA','RUA JOSE VIGLETTI','SAO PAULO','SP','02218090','11 22125997', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (1331,'084.613.208-75','AGILMAR DO NASCIMENTO GUIMARAES','1965-01-29','16.431.524-X','M','SEPAR.JUDIC','ARNALDO MACHADO GUIMARÃES','MARIA DE LOURDES DO NASCIMENTO GUIMARÃES','RUA TAVANNES','São Paulo','SP','02443090','11 23590147', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (1351,'018.020.098-41','MARCIO VENEZIANO','1960-08-11','298655913','M','OUTROS','ARTHUR VENEZIANO','BENEDITA DE OLIVEIRA','R TAMBAU ','GUARUJA','SP','11451170','13 30174206', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (1461,'097.825.188-16','HILDA MEDEIROS DA SILVA','1951-08-27','30.771.896-7','F','VIUVO','HELIO DA SILVA','BENEDITA MEDEIROS DA SILVA','CAM MONSENHOR MOREIRA ','SANTOS','SP','11013760','13 32216040', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (1637,'221.250.781-04','NADIA FURTADO DE ANDRADE','1960-10-31','554.062','F','SOLTEIRO','ADYR VIEIRA DE ANDRADE','DILMA FURTADO DE ANDRADE','Rua Doutor Antônio Cansanção','Maceió','AL','57035190','82 33163433', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (1693,'802.634.108-20','HAVILA MEIRE DA SILVA','1954-11-14','7.255.413-7','F','SOLTEIRO','ALTINO JOSÉ DA SILVA','IRIA VIEIRA DA COSTA SILVA','AV CARAMURU','RIBEIRÃO PRETO','SP','14025710','16 36216563', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (1852,'025.557.718-40','LANA CRISTINA FERRETE','1961-10-06','14.122.254-2','F','DIVORCIADO','NILTON LUIZ FERRETE','MARLENE ALVES FERRETE','Rua Liberdade','Santos','SP','11025030','13 32274676', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (1888,'057.484.021-49','JOAO XAVIER DE ARRUDA','1951-06-06','243.752','M','CASADO','NÃO DECLARADO','NEUZA XAVIER DE ARRUDA','Quadra QR 414 Conjunto 12','Brasília','DF','72320216','61 33576295', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2048,'252.437.198-03','ALEXANDRE BATEL','1976-12-06','27.484.937-9','M','SOLTEIRO','ANTONIO BATEL NETO','MARIA JOSE BATEL','Rua Frei Orlando','São Paulo','SP','03432010','11 27838252', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2128,'039.546.638-56','MARLUCE FRANCA SILVA DE OLIVEIRA','1962-07-03','15.288.986-3','F','CASADO','FRANCISCO VIANA DA SILVA','MARIA MARLENE DE FRANÇA SILVA','Caminho Monsenhor Moreira','Santos','SP','11013760','13 32345486', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2135,'033.749.711-72','FRANCISCO FELIX DE ARAUJO','1947-12-14','194499','M','CASADO','INÁCIO  FELIX DE ARAUJO','INÁCIA  DA COSTA  ARAUJO','Quadra QMS 48','Brasília','DF','73080260','61 32974811', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2171,'059.379.988-71','ALEXANDRE ABDALA JUNIOR','1963-01-12','116211192','M','SOLTEIRO','ALEXANDRE ABDALA','MIRIAM MELLO ABDALA','Rua Sérgio Porto','Guarulhos','SP','07114020','11 24080926', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2196,'024.998.433-49','JOSE CLAIRTON SILVA ALMEIDA','1951-10-07','2006009027670','M','CASADO','RAIMUNDO GUEDES DE ALMEIDA','MARIA MARGARIDA DA SILVA  ALMEIDA','Avenida José do Patrocínio','Fortaleza','CE','60410150','85 34911124', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2226,'238.663.301-20','MARIA DE LOURDES SILVA XAVIER','1944-05-18','153443','F','CASADO','GUSTAVO DORNELAS DA SILVA','MARIA JOSÉ DO NASCIMENTO','QR 414 CONJUNTO 12','Brasília','DF','72320216','61 33576295', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2486,'018.188.038-52','NEIDE APARECIDA DA CRUZ SILVA','1951-06-21','13.621.163-X','F','COMPANHEIRO','PEDRO MAXIMIANO DA CRUZ','ADELINA FIRMINA DA CRUZ','Rua Barão do Rio Branco','Guarujá','SP','11451042','13 33414521', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2561,'728.329.408-20','DIRSON DE SOUZA BENTO','1944-11-26','3.849.880-7','M','COMPANHEIRO','ZACARIAS JOAQUIM BENTO','EVA RIBEIRO DE SOUZA','Rua dos Carvalhos','Praia Grande','SP','11712510','13 34774305', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2796,'007.252.358-10','MARIA APARECIDA ALVES PINTO','1946-09-10','3.613.817-4','F','CASADO','ACACIO TOMAZ ALVES','MARCOLINA JULIA DE FEO FLORA  ALVES','Rua Domiciano Ribeiro','São Paulo','SP','02565090','11 22398682', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (2920,'433.263.828-04','PEDRO LUIZ DA COSTA FILHO','1950-02-16','48624548','M','CASADO','PEDRO LUIZ DA COSTA','TERESA GONÇALVES DA COSTA','R ARISTOTELES FERREIRA ','SANTOS','SP','11020140','13 33854557', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (3089,'158.932.348-39','SONIA REGINA FARIA VIEIRA','1956-08-03','13621324-8','F','VIUVO','ANTONIO FARIA GOMES','CAROLINA VARGAS FARIA','R ANTONIO FERNANDES ','GUARUJA','SP','11430340','13 33044759', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (3180,'127.893.567-34','ADELCYR CORREA MACHADO','1935-12-30','01.789.771-1','F','SOLTEIRO','ANTONIO NATALICIO MACHADO','ZULEIKA IGNACIO CORREA MACHADO','Rua Pernambuco','Rio de Janeiro','RJ','20730030','21 38992687', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (3299,'512.545.301-34','CELINA FERREIRA LONGO','1938-01-23','122678272-8','F','VIUVO','TOME FRANKLIN FERREIRA','ROSA CARDOSO FERREIRA','QD 103 ','BRASILIA','DF','71909000','61 34357562', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (3304,'788.826.648-72','ROSEMARY EDLINGER PEREIRA LOPES','1948-05-13','5629560-1','F','SOLTEIRO','JOSÉ BENEDICTO PEREIRA LOPES','MIRARIR EDLINGER LOPES','Rua Guaratinguetá','Taubaté','SP','12060210','12 36332449', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (3349,'094.747.813-20','ALCENILDES CORREA REIS','1954-01-05','0529305520147','F','COMPANHEIRO','VENANCIO VALERIO DOS REIS','ZILDA CORREA REIS','Rua Manoel Jansen Ferreira','São Luís','MA','65074170','98 32224071', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (3431,'077.813.518-78','IONE MACIEL','1958-04-02','189024586','F','SOLTEIRO','BENEDITO MACIEL','MARIA JOSÉ DOS SANTOS','RUA CINQUENTA E OITO ','SÃO VICENTE','SP','11301000','13 35641440', DATE());
    INSERT INTO cliente (codigo,cpf,nome,dataNascimento,rg,sexo,estadoCivil,pai,mae,endereco,cidade,estado,cep,telefone, dataInclusao) VALUES (3436,'102.095.468-08','ERIDULCE FERREIRA NEIVA','1943-12-24','5534463X','F','OUTROS','CICERO FERREIRA DE MELO','FELICIDADE FERREIRA MELO','RUA SILVIO RIZZARDO ','CAMPINAS','SP','13060077','19 32290837', DATE());

. Acesse o Postman e execute a rota abaixo:

    url: http://localhost:[porta]/cliente/v1/pageable
    method: GET

    . Vira 25 registros por página, que é o default do "pageSize"

. Acesse o Postman e execute a rota abaixo e vá executando modificando o número da página ( page = 1,2,3,4,5,...):

    url: http://localhost:[porta]/cliente/v1/pageable?page=1&pageSize=2&orderBy=nome
    method: GET

    . Virá somente os registros da primeira página com 2 registros






Adicionando Autorização e Autenticação com Token
================================================

. Inclua as classes models abaixo na pasta "Model":


    // Classe "User"
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.ComponentModel.DataAnnotations.Schema;

    namespace contrato.Models
    {
        [Table("user")]
        public class User
        {
            [Key]
            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
            [Column("id", Order = 1)]
            public int Id { get; set; }

            [Required(ErrorMessage = "Preenchimento obrigatório")]
            [MinLength(3, ErrorMessage = "Tamanho mínimo de 3 caracteres")]
            [MaxLength(50, ErrorMessage = "Tamanho maximo de 50 caracteres")]
            [Column("name", TypeName = "VARCHAR(50)")]
            public string Name { get; set; }

            [Required(ErrorMessage = "Preenchimento obrigatório")]
            [EmailAddress]
            [MinLength(10, ErrorMessage = "Tamanho mínimo de 10 caracteres")]
            [MaxLength(50, ErrorMessage = "Tamanho maximo de 50 caracteres")]
            [Column("email", TypeName = "VARCHAR(50)")]
            public string Email { get; set; }

            [Column("passwordHash", TypeName = "VARCHAR(100)")]
            public string PasswordHash { get; set; }

            [Column("password", TypeName = "VARCHAR(15)")]
            [Required(ErrorMessage = "Password é obrigatório")]
            [MinLength(3, ErrorMessage = "Tamanho mínimo da senha deve ser de 3 caracateres")]
            [MaxLength(15, ErrorMessage = "Tamanho máximo da senha deve ser de 15 caracateres")]
            public string Password { get; set; }

            public List<UserRole> Roles { get; set; }
        }
    }

    // Classe "Role"
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using System.ComponentModel.DataAnnotations.Schema;

    namespace contrato.Models
    {

        [Table("role")]
        public class Role
        {
            [Key]                   
            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]  
            [Column("id", Order=1)]
            public int Id { get; set; }

            [Required(ErrorMessage = "Preenchimento obrigatório")]                              
            [MinLength(3, ErrorMessage ="Tamanho mínimo de 3 caracteres")]                          
            [MaxLength(50, ErrorMessage = "Tamanho maximo de 50 caracteres")]                         
            [Column("Name", TypeName = "VARCHAR(50)")] 
            public string Name { get; set; }

            [Column("defaultRole", TypeName = "CHAR(1)")]
            [DefaultValue("N")]
            // [DataType(DataType.Text)]
            public string DefaultRole{ get; set;}
        }
    }

    // Classe "UserRole"
    using System.ComponentModel.DataAnnotations;
    using System.ComponentModel.DataAnnotations.Schema;

    namespace contrato.Models
    {
        [Table("UserRole")]
        public class UserRole
        {
            [Key]                   
            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]  
            [Column("id", Order=1)]
            public int Id { get; set; }

            [Column(Order = 2)]
            public int UserId { get; set; }        

            [Column(Order = 3)]
            public int RoleId { get; set; }

            [ForeignKey("UserId")]
            public User User{ get; set; }

            [ForeignKey("RoleId")]
            public Role Role { get; set; }
        }
    }

. Insira as linhas abaixo na classe "Data/AppDbContext.cs"

    using System;
    using contrato.Models;
    using Microsoft.EntityFrameworkCore;

    namespace contrato.Data
    {
        public class AppDbContext: DbContext
        {
            public AppDbContext(DbContextOptions<AppDbContext> options ) : base(options)
            {
            }

            protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)   // Método alterado
            {
                optionsBuilder.UseSqlite();
                optionsBuilder.LogTo( Console.WriteLine );     // Linha inserida
            }

            public DbSet<Cliente> Clientes { get; set; }
            public DbSet<User> Users { get; set; }              // Linha inserida
            public DbSet<Role> Roles { get; set; }              // Linha inserida
            public DbSet<UserRole> UserRole { get; set; }       // Linha inserida
        }
    }

. Execute os comandos abaixo na pasta raiz do projeto:

    dotnet clean
    dotnet build
    dotnet ef migrations add SecondCreation
    dotnet ef database update

. Acesse o banco de dados e execute as DMLs abaixo:

    INSERT INTO Role( name, defaultRole ) VALUES('user', 'S');
    INSERT INTO Role( name, defaultRole ) VALUES('admin', 'N');

. Adicione as packages abaixo no projeto:

    dotnet add package Microsoft.AspNetCore.Authentication  --version  2.2.0

    dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version  5.0.17

    dotnet clean

    dotnet restore

    dotnet build


. Adapte o arquivo "appsettings.Development.json" como abaixo:

    ...
    "JwtKey": "ZmVkYWY3ZDg4NjNiNDhlMTk3YjkyODdkNDkyYjcwOGU=",
    "ApiKeyName": "api_key",
    "ApiKey": "curso_api_IlTevUM/z0ey3NwCV/unWg==",
    "TokenExpireIn": 10800,
    "TokenExpireInUnit": "seconds" 

    ...

. Insira o arquivo "ConfigHelper.cs" na raiz do projeto como abaixo:

    namespace contrato
    {
        public static class ConfigHelper
        {
            public static string JwtKey;
            public static string ApiKeyName;
            public static string ApiKey;
            public static int TokenExpireIn;
            public static string TokenExpireInUnit; 

        }
    }

. Crie a pasta "Services" na raiz do projeto e crie as classes abaixo:

    // Classe "TokenService"

    using System;
    using System.IdentityModel.Tokens.Jwt;
    using System.Text;
    using contrato.Models;
    using Microsoft.IdentityModel.Tokens;

    namespace contrato.Services
    {
        public class TokenService
        {
            public string GenerateToken(User user)
            {
                // Classe responsável por gerar o token
                var tokenHandler = new JwtSecurityTokenHandler();

                // Nossa chave de validação do token
                var key = Encoding.ASCII.GetBytes(ConfigHelper.JwtKey);

                // Informações contidas no nosso token
                var tokenDescriptor = new SecurityTokenDescriptor()
                {
                    // Tempo de expiração do nosso token
                    Expires = ConfigHelper.TokenExpireInUnit.Equals("seconds") ? DateTime.UtcNow.AddSeconds( ConfigHelper.TokenExpireIn ): 
                                                                                 DateTime.UtcNow.AddHours( ConfigHelper.TokenExpireIn ),
                    // Credenciais para incriptar e desincriptar nosso token
                    SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key),
                                                                    SecurityAlgorithms.HmacSha256Signature)
                };

                // Criação do token
                var token = tokenHandler.CreateToken(tokenDescriptor);

                return tokenHandler.WriteToken(token);

            }
        }
    }


    // Classe AccountService

    using System;
    using System.Linq;
    using System.Threading.Tasks;
    using contrato.Data;
    using contrato.Models;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.EntityFrameworkCore;

    namespace contrato.Services
    {
        public class AccountService
        {
            AppDbContext _context;

            public AccountService(AppDbContext context)
            {
                _context = context;
            }
            public async Task  GrantRoleAsync(int userId, 
                                        string roleName)
            {
                Role role = await _context.Roles
                                .AsNoTracking()
                                .FirstOrDefaultAsync( x => x.Name == roleName);

                UserRole userRole = new UserRole{
                    UserId = userId,
                    RoleId = role.Id
                };

                await _context.UserRole.AddAsync( userRole );
                await _context.SaveChangesAsync();
            }


            public async Task GrantDefaultRole( int userId )
            {
                var roles = await _context.Roles
                                    .AsNoTracking()
                                    .Where( r => r.DefaultRole == "S")
                                    .ToListAsync();
                foreach( var item in roles )
                {
                    await GrantRoleAsync( userId, item.Name );

                }
            }
        }
    }

. Adicione as linhas abaixo na classe "Startup.cs"

    ...
    public void ConfigureServices(IServiceCollection services)
    {
        var connectionStrings = Configuration.GetConnectionString("DefaultConnection");     

        ConfigHelper.JwtKey = Configuration.GetValue<string>( "JwtKey" );              // Linha Inserida
        ConfigHelper.ApiKeyName = Configuration.GetValue<string>( "ApiKeyName" );      // Linha Inserida
        ConfigHelper.ApiKey = Configuration.GetValue<string>( "ApiKey" );               // Linha Inserida
        ConfigHelper.TokenExpireIn = Configuration.GetValue<int>("TokenExpireIn");     // Linha Inserida
        ConfigHelper.TokenExpireInUnit = Configuration.GetValue<string>("TokenExpireInUnit");     // Linha Inserida

        services.AddDbContext<AppDbContext>(options =>                                      
            options.UseSqlite(connectionStrings));
            
        services.AddTransient<TokenService>();                              // Linha inserida
        services.AddTransient<AccountService>();                            // Linha inserida

        services.AddControllers()
                .ConfigureApiBehaviorOptions(options =>        
                                            {                                                       
                                                options.SuppressModelStateInvalidFilter = true;     
                                            });            

        services.AddControllers();
        services.AddSwaggerGen(c =>
        {
            c.SwaggerDoc("v1", new OpenApiInfo { Title = "contrato", Version = "v1" });
        });
    }
    ...

. Inclua a classe "RegisterViewModel" dentro da pasta "ViewModels":

    using System.ComponentModel.DataAnnotations;

    namespace contrato.ViewModels
    {
        public class RegisterViewModel
        {
            [Required(ErrorMessage = "O nome é obrigatório")]
            public string Name { get; set; }
            
            [Required(ErrorMessage = "O E-mail é obrigatório")]
            [EmailAddress(ErrorMessage = "O E-mail é inválido")]
            public string Email { get; set; }

            [Required(ErrorMessage = "Password é obrigatório")]
            [MinLength(3, ErrorMessage = "Tamanho mínimo da senha deve ser de 3 caracateres")]
            [MaxLength(15, ErrorMessage = "Tamanho máximo da senha deve ser de 15 caracateres")]
            public string Password { get; set; }
        }
    }

. Inclua a classe "LoginViewModel" dentro da pasta "ViewModels":

    using System.ComponentModel.DataAnnotations;

    namespace contrato.ViewModels
    {
        public class LoginViewModel
        {
            [Required(ErrorMessage = "Informe o E-mail")]
            [EmailAddress(ErrorMessage = "E-mail inválido")]
            public string Email { get; set; }

            [Required(ErrorMessage = "Informe a senha")]
            public string Password { get; set; }
        }
    }

. Execute o comando abaixo na raiz do projeto:

    dotnet add package SecureIdentity --version 1.0.3

. Crie a classe "AccountController" dentro da pasta "Controllers":

    using System.Threading.Tasks;
    using contrato;
    using contrato.Data;
    using contrato.Extensions;
    using contrato.Models;
    using contrato.Services;
    using contrato.ViewModels;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.EntityFrameworkCore;
    using SecureIdentity.Password;

    namespace contrato.Controllers
    {
        [ApiController]
        [Route("[controller]")]
        public class AccountController : ControllerBase
        {
            [HttpPost("v1")]
            public async Task<IActionResult> Post(
                [FromBody] RegisterViewModel model,
                [FromServices] AppDbContext context)
            {
                if (!ModelState.IsValid)
                    return BadRequest(new ResultViewModel<string>(ModelState.GetErrors()));

                var user = new User
                {
                    Name = model.Name,
                    Email = model.Email,
                    Password = model.Password
                };

                var password = PasswordGenerator.Generate(25);
                user.PasswordHash = PasswordHasher.Hash(password);

                try
                {
                    await context.Users.AddAsync(user);
                    await context.SaveChangesAsync();

                    return Ok(new ResultViewModel<dynamic>(new
                    {
                        user = user.Email,
                        password
                    }));
                }
                catch (DbUpdateException)
                {
                    return StatusCode(400, new ResultViewModel<string>("05X99 - Este E-mail já está cadastrado"));
                }
                catch
                {
                    return StatusCode(500, new ResultViewModel<string>("05X04 - Falha interna no servidor"));
                }
            }

            [HttpPost("v1/login")]
            public async Task<IActionResult> Login(
                [FromBody] LoginViewModel model,
                [FromServices] AppDbContext context,
                [FromServices] TokenService tokenService)
            {
                if (!ModelState.IsValid)
                    return BadRequest(new ResultViewModel<string>(ModelState.GetErrors()));

                var user = await context
                    .Users
                    .AsNoTracking()
                    .Include(x => x.Roles)
                        .ThenInclude( x => x.Role )
                    .FirstOrDefaultAsync(x => x.Email == model.Email);

                if (user == null)
                    return StatusCode(401, new ResultViewModel<string>("Usuário ou senha inválidos"));

                if (!PasswordHasher.Verify(user.PasswordHash, model.Password))
                    return StatusCode(401, new ResultViewModel<string>("Usuário ou senha inválidos"));

                try
                {
                    var token = tokenService.GenerateToken(user);
                    return Ok(new ResultViewModel<dynamic>(new 
                                                            { 
                                                                accessToken = token,
                                                                tokenType = "Bearer",
                                                                tokenExpireIn = ConfigHelper.TokenExpireIn,
                                                                tokenExpireInUnit = ConfigHelper.TokenExpireInUnit,
                                                                refreshToken = "",
                                                            }, null));
                }
                catch
                {
                    return StatusCode(500, new ResultViewModel<string>("05X04 - Falha interna no servidor"));
                }
            }
        }
    }

. Execute a URL abaixo no Postman:

    method: POST
    url: http://localhost:[porta]/account/v1
    body.json: true
    body.raw: 
        {
            "email": "jose.silva@encoder.com",
            "Name": "Jose da Silva",
            "password": "jose"
        }

    . Guarde o retorno da rota acima, principalmente a "password" para utilizar na aula seguinte. Por exemplo:

        {
            "data": {
                "user": "jose.silva@encoder.com",
                "password": "U8{bT[]0Bpq7}z#Qz)aIk6MHx"
            },
            "errors": []
        }

        {
            "data": {
                "user": "administrator@encoder.com",
                "password": "!6LA94et%1]ntRBPt)yJa9#0w"
            },
            "errors": []
        }

. Execute a URL abaixo no Postman:

    method: POST
    url: https://localhost:[porta]/account/v1/login
    body.json: true
    body.raw: 
        {
            "email": "jose.silva@encoder.com",
            "password": "U8{bT[]0Bpq7}z#Qz)aIk6MHx"
        }

    . Guarde o token gerado para futuras consultas

. Acesse a classe "Startup.cs" e insira as linhas abaixo para habilitar a autenticação e a autorização 
    no nosso projeto, obrigatório ser nessa ordem:

    using contrato.Services;
    using contrato.Data;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Hosting;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Hosting;
    using Microsoft.OpenApi.Models;
    using System.Text;
    using Microsoft.AspNetCore.Authentication.JwtBearer;
    using Microsoft.IdentityModel.Tokens;

    ...
    public void ConfigureServices(IServiceCollection services)
    {
        ...

        // Linha inserida. Pode colocar no final do metodo
        var key = Encoding.ASCII.GetBytes( ConfigHelper.JwtKey );           // 

        // Linha abaixo inserida, não é para alterar
        services.AddAuthentication(x =>
        {
            x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
        }).AddJwtBearer(x =>
        {
            x.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = false,
                ValidateAudience = false
            };
        });
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        ...
        app.UseAuthentication();    // Linha inserida   "Nessa ordem"
        app.UseAuthorization();     // Linha inserida   "Nessa ordem"
    }

. Dentro da classe AccountController crie os métodos abaixo:

    ...
    using Microsoft.AspNetCore.Authorization;       // Linha inserida

    [ApiController]
    public class AccountController: ControllerBase
    {
        ...                                         

        // Métodos abaixo inseridos
        [Authorize]                     
        [HttpGet("v1/user")]
        public IActionResult GetUser() => Ok( new ResultViewModel<string>("GetUser Authorized") );

        [Authorize]                     
        [HttpGet("v1/admin")]
        public IActionResult GetAdmin() => Ok( new ResultViewModel<string>("GetUser Authorized") );
        ...
    }


. Execute a URL abaixo no Postman:

    method: POST
    url: https://localhost:[porta]/account/v1/login
    body.json: true
    body.raw: 
        {
            "email": "jose.silva@encoder.com",
            "password": "U8{bT[]0Bpq7}z#Qz)aIk6MHx"
        }

    . Guarde o token gerado para futuras consultas

. Acesse o Postman e execute a URL abaixo:

    url: https://localhost:[porta]/account/v1/user
    method: GET
    Authorization.Type: Bearer Token
    Authorization.Token: [token obtido no item anterior]

. Acesse o Postman e execute a URL abaixo:

    url: https://localhost:[porta]/account/v1/admin
    method: GET
    Authorization.Type: Bearer Token
    Authorization.Token: [token obtido no item anterior]

    ou

    url: https://localhost:[porta]/account/v1/admin
    method: GET
    Headers.Authorization: Bearer [Token obtido no item anterior]


Autorização baseada em Claims via JWT
=====================================

. Dentro da pasta "Extensions" crie a classe abaixo:

    using System.Collections.Generic;
    using System.Linq;
    using System.Security.Claims;
    using contrato.Models;

    namespace contrato.Extensions
    {
        public static class RoleClaimsExtension
        {
            public static IEnumerable<Claim> GetClaims(this User user)
            {
                var result = new List<Claim>
                    {
                        new(ClaimTypes.Name, user.Email)
                    };
                result.AddRange(
                    user.Roles.Select(role => new Claim(ClaimTypes.Role, role.Role.Name ))
                );
                return result;
            }
        }
    }

. Acesse a classe "TokenService" e faça as alterações abaixo:

    using contrato.Extensions;     // Linha inserida
    using System.Security.Claims;   // Linha inserida
    ...
    public class TokenService
    {
        public string GenerateToken(User user)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(Configuration.JwtKey);

            var claims = user.GetClaims();              // Linha inserida

            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),       // Linha alterada
                Expires = DateTime.UtcNow.AddHours(8),
                SigningCredentials = new SigningCredentials(
                    new SymmetricSecurityKey(key),
                    SecurityAlgorithms.HmacSha256Signature)
            };
            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }
    }
    ...    

. Execute as DMLS abaixo para criar as roles para o usuário "jose.silva@encoder.com":

    INSERT INTO UserRole( UserId, RoleId ) 
    VALUES( 4,  1);
            |   |
            |   +-> Role de "user"
            |
            +-> Código do usuário "jose.silva@encoder.com"

    . Futuramente substituir esse comando por uma rota de criação de role para o usuário

. Altere os retornos dos métodos abaixo da classe "AccountController":

    ...
    [Authorize( Roles = "user")]        // Linha alterada                  
    [HttpGet("v1/user")]
    public IActionResult GetUser() => Ok( User.Identity.Name ); // Linha alterada

    [Authorize( Roles = "admin" )]     // Linha alterada
    [HttpGet("v1/admin")]
    public IActionResult GetAdmin() => Ok( User.Identity.Name ); // Linha alterada
    ...

. Execute a URL abaixo no Postman:

    method: POST
    url: https://localhost:[porta]/account/v1/login
    body.json: true
    body.raw: 
        {
            "email": "jose.silva@encoder.com",
            "password": "U8{bT[]0Bpq7}z#Qz)aIk6MHx"
        }

    . Guarde o token gerado para futuras consultas

. Acesse o Postman e execute a URL abaixo:

    url: https://localhost:[porta]/account/v1/user
    method: GET
    Authorization.Type: Bearer Token
    Authorization.Token: [token obtido no item anterior]

. Acesse o Postman e execute a URL abaixo:

    url: https://localhost:[porta]/account/v1/admin
    method: GET
    Authorization.Type: Bearer Token
    Authorization.Token: [token obtido no item anterior]

    ou

    url: https://localhost:[porta]/account/v1/admin
    method: GET
    Headers.Authorization: Bearer [Token obtido no item anterior]

. Vamos fechar a possibilidade de qualquer um incluir um novo login, somente usuários com a role de "admin"
    terão essa responsabilidade.


. Execute a URL abaixo no Postman:

    method: POST
    url: http://localhost:[porta]/account/v1
    body.json: true
    body.raw: 
        {
            "email": "administrator@encoder.com",
            "Name": "Administrator",
            "password": "administrator"
        }

    . Guarde o retorno da rota acima, principalmente a "password" para utilizar na aula seguinte.

        {
            "data": {
                "user": "administrator@encoder.com",
                "password": "@K6DRzguOuQDI)8hP1F;3Q6c2"
            },
            "errors": []
        }

. Execute o comando abaixo no banco de dados, isto será feito para identificar o "administrator" como "admin". 
    Futuramente alterar em fazer isso através de um rota:

    INSERT INTO UserRole( UserId, RoleId ) 
    VALUES( [UserId],  [RoleId]);
            |           |
            |           +-> Role de "admin"
            |
            +-> Código do usuário "administrator@encoder.com"


. Vamos automatizar a inclusão da role "user" para qualquer usuário incluido.

. Altere as linhas do método abaixo da classe "AccountController":

        [HttpPost("v1")]
        [Authorize( Roles = "admin" ) ]             // Linha inserida
        public async Task<IActionResult> Post(
            [FromBody] RegisterViewModel model,
            [FromServices] AppDbContext context,
            [FromServices] AccountService accountService)    // Linha inserida
        {
            if (!ModelState.IsValid)
                return BadRequest(new ResultViewModel<string>(ModelState.GetErrors()));

            var user = new User
            {
                Name = model.Name,
                Email = model.Email,
                Password = model.Password
            };

            var password = PasswordGenerator.Generate(25);
            user.PasswordHash = PasswordHasher.Hash(password);


            // Bloco Try/Catch abaixo refeito
            try
            {
                await context.Database.BeginTransactionAsync();         

                await context.Users.AddAsync(user);
                await context.SaveChangesAsync();

                // Criação dos roles default
                await accountService.GrantDefaultRole( user.Id );       


                await context.Database.CommitTransactionAsync();

                return Ok(new ResultViewModel<dynamic>(new
                {
                    user = user.Email,
                    password
                }));
            }
            catch (DbUpdateException)
            {
                await context.Database.RollbackTransactionAsync();

                return StatusCode(400, new ResultViewModel<string>("05X99 - Este E-mail já está cadastrado"));
            }
            catch
            {
                await context.Database.RollbackTransactionAsync();

                return StatusCode(500, new ResultViewModel<string>("05X04 - Falha interna no servidor"));
            }
        }

. Para incluir um login de agora em diante precisaremos da role "admin". O login "administrator@encoder.com"
    possui essa autorização. Execute a rota abaixo no Postman:

    method: POST
    url: https://localhost:[porta]/account/v1/login
    body.json: true
    body.raw: 
        {
            "email": "administrator@encoder.com",
            "password": "@K6DRzguOuQDI)8hP1F;3Q6c2"
        }

    . Guarde o token gerado para a proxima consulta


    method: POST
    url: http://localhost:[porta]/account/v1
    Headers.Authorization: Bearer [Token obtido no item anterior]
    body.json: true
    body.raw: 
        {
            "email": "geronimo.silva@encoder.com",
            "Name": "Geronimo da Silva",
            "password": "geronimo"
        }

. Desenvolvimento da rota para cadastrar as roles dos usuários

. Execute os comandos abaixo no banco de dados:

    INSERT INTO Role( Name, defaultRole )
    VALUES('guest', 'N'),
            ('marketing', 'N'),
            ('finance', 'N'),
            ('humanResource', 'N');

. Inclua a classe abaixo na pasta "ViewModels":

    using System.ComponentModel.DataAnnotations;

    namespace contrato.ViewModels
    {
        public class UserRoleViewModel
        {
            [Required(ErrorMessage = "Preenchimento obrigatório")]                              
            [EmailAddress]
            [MinLength(10, ErrorMessage ="Tamanho mínimo de 10 caracteres")]                          
            [MaxLength(50, ErrorMessage = "Tamanho maximo de 50 caracteres")]                         
            public string Email { get; set; }

            [Required(ErrorMessage = "Preenchimento obrigatório")]                              
            [MinLength(3, ErrorMessage ="Tamanho mínimo de 3 caracteres")]                          
            [MaxLength(50, ErrorMessage = "Tamanho maximo de 50 caracteres")]                         
            public string RoleName { get; set; }
        }
    }

. Implemente o método abaixo na classe "AccountController.cs":

    ...
    [HttpPost("v1/grant-roles")]
    [Authorize( Roles = "admin")]
    public async Task<IActionResult> GrantRole([FromBody] List<UserRoleViewModel> roles,
                                                [FromServices] AppDbContext context )
    {

        if (!ModelState.IsValid)
        {
            return BadRequest( new ResultViewModel<string>( ModelState.GetErrors()  ));
        }

        List<UserRole> userRolesAdd = new List<UserRole>();
        List<string> errors = new List<string>();

        roles.ForEach(async userRole => {
            System.Console.WriteLine( $"{userRole.Email} - {userRole.RoleName}");

            Role role = await context.Roles
                                .AsNoTracking()
                                .FirstOrDefaultAsync( x => x.Name == userRole.RoleName );

            User user = await context.Users
                                .AsNoTracking()
                                .FirstOrDefaultAsync( x => x.Email == userRole.Email );

            if (  role != null 
                ||  user != null ) 
            {

                UserRole ur = await context.UserRole
                                        .AsNoTracking()
                                        .FirstOrDefaultAsync( x => x.UserId == user.Id 
                                                                    && x.RoleId == role.Id );

                if ( ur == null )
                {
                    userRolesAdd.Add( new UserRole{
                        UserId = user.Id,
                        RoleId = role.Id
                    } );
                }
            } else
            {
                errors.Add( $"{userRole.Email} ou {userRole.RoleName} Inválido" );
            }
        });

        try
        {
            if ( userRolesAdd.Count > 0 
                &&  errors.Count == 0 )
            {
                await context.AddRangeAsync( userRolesAdd );
            
                await context.SaveChangesAsync();
            }

            if ( errors.Count == 0 )
            {
                return Ok();
            } else
            {
                return BadRequest( new ResultViewModel<List<string>>( errors ) );
            }
        } catch( Exception ex )
        {
            return StatusCode( 500, $"Falha Interna [ {ex.Message} ]");
        }
    }
    ...

. Execute as rotas abaixo no Postman para criar as roles num determinado usuário:

    method: POST
    url: https://localhost:[porta]/account/v1/login
    body.json: true
    body.raw: 
        {
            "email": "administrator@encoder.com",
            "password": "@K6DRzguOuQDI)8hP1F;3Q6c2"
        }

    . Guarde o token gerado para a proxima consulta

    method: POST
    url: https://localhost:5001/account/v1/grant-roles
    Headers.Authorization: Bearer [Token obtido no item anterior]
    body.json: true
    body.raw: 
        [
            { 
                "Email": "joaquim@encoder.com",
                "RoleName": "guest"
            },
            { 
                "Email": "joaquim@encoder.com",
                "RoleName": "finance"
            },
            { 
                "Email": "joaquim@encoder.com",
                "RoleName": "marketing"
            },
            { 
                "Email": "joaquim@encoder.com",
                "RoleName": "humanResource"
            }
        ]




Renovando o Access Token com o Refresh Token
============================================

. Acrescente as propriedades abaixo na classe "User.cs":

    ...
    [Column("token", TypeName = "VARCHAR(255)")]
    public string Token { get; set; }

    [Column("refreshToken", TypeName = "VARCHAR(255)")]
    public string refreshToken { get; set; }

    [Column( "refreshTokenExpire", TypeName = "DATETIME")]
    public DateTime refreshTokenExpire { get; set; }
    ...

. Execute os comandos abaixo na pasta raiz do projeto:

    dotnet clean

    dotnet build

    dotnet ef migrations add InitialCreation

    dotnet ef database update

. Acrescente a propriedade abaixo na classe "ConfigHelper":

    namespace contrato
    {
        public static class ConfigHelper
        {
            ...

            public static int RefreshTokenExpireIn; // Linha inserida
        }
    }

. Acrescente a linha abaixo no arquivo "appsettings.Development.json":

    {
    "Logging": {
        "LogLevel": {
        "Default": "Information",
        "Microsoft": "Warning",
        "Microsoft.Hosting.Lifetime": "Information"
        }
    },
    "ConnectionStrings": {
        "DefaultConnection": "DataSource=app.db;Cache=Shared"
    },
    "JwtKey": "ZmVkYWY3ZDg4NjNiNDhlMTk3YjkyODdkNDkyYjcwOGU=",
    "ApiKeyName": "api_key",
    "ApiKey": "curso_api_IlTevUM/z0ey3NwCV/unWg=="  ,
    "TokenExpireIn": 10800,
    "TokenExpireInUnit": "seconds",
    "RefreshTokenExpireIn": 604800          // Linha inserida
    }

. Crie a pasta "Repositories" e dentro dela a classe "TokenRepository":

    using System;
    using System.Threading.Tasks;
    using contrato;
    using contrato.Data;
    using Microsoft.EntityFrameworkCore;

    namespace contrato.Repositories
    {
        public class TokenRepository
        {

            public AppDbContext _context { get; set; }
            public TokenRepository(AppDbContext context)
            {
                _context = context;
            }

            public async Task SaveRefreshTokenAsync( string email, string token, string refreshToken)
            {
                var user = await _context.Users
                                .AsNoTracking()
                                .FirstOrDefaultAsync( x => x.Email == email );

                if ( user == null )
                {
                    throw new Exception("Usuário não cadastrado");
                }

                user.Token = token;
                user.RefreshToken = refreshToken;
                user.RefreshTokenExpire = ConfigHelper.TokenExpireInUnit.Equals("seconds") ? DateTime.UtcNow.AddSeconds(ConfigHelper.RefreshTokenExpireIn) :
                                                                            DateTime.UtcNow.AddHours(ConfigHelper.RefreshTokenExpireIn);

                try
                {
                    _context.Users
                            .Update( user );

                    await _context.SaveChangesAsync();
                } catch( Exception ex )
                {
                    throw ex;
                }

            }

        }
    }


. Acrescente a linha abaixo na classe "Startup.cs":

    namespace contrato
    {
        public class Startup
        {
            public void ConfigureServices(IServiceCollection services)
            {
                var connectionStrings = Configuration.GetConnectionString("DefaultConnection");     

                ConfigHelper.JwtKey = Configuration.GetValue<string>("JwtKey");              
                ConfigHelper.ApiKeyName = Configuration.GetValue<string>( "ApiKeyName" );    
                ConfigHelper.ApiKey = Configuration.GetValue<string>( "ApiKey" );            
                ConfigHelper.TokenExpireIn = Configuration.GetValue<int>( "TokenExpireIn");  
                ConfigHelper.TokenExpireInUnit = Configuration.GetValue<string>( "TokenExpireInUnit"); 

                ConfigHelper.RefreshTokenExpireIn = Configuration.GetValue<int>( "RefreshTokenExpireIn");       // Linha Inserida
                ...
                services.AddTransient<TokenRepository>();                                                       // Linha inserida
                ...
            }

            ...
        }
    }

. Insira a classe "RefreshTokeViewModel" abaixo na pasta "ViewModels":

    namespace contrato.ViewModels
    {
        public class RefreshTokenViewModel
        {
            public string Token { get; set; }        
            public string RefreshToken { get; set; }
        }
    }


. Inclua os métodos abaixo na classe "TokenService.cs":

    public class TokenService
    {
        TokenRepository _tokenRepository;                           // Linha inserida
        AppDbContext _context;                                      // Linha inserida

        public TokenService(TokenRepository tokenRepository,        // Construtor inserido
                                AppDbContext context)
        {
            _tokenRepository = tokenRepository;
            _context = context;
        }

        ...
        public string GenerateToken(User user)                  // Metodo Alterado
        {
            // Classe responsável por gerar o token
            var tokenHandler = new JwtSecurityTokenHandler();

            // Nossa chave de validação do token
            var key = Encoding.ASCII.GetBytes(ConfigHelper.JwtKey);

            var claims = user.GetClaims();

            // Informações contidas no nosso token
            var tokenDescriptor = new SecurityTokenDescriptor()
            {
                Subject = new ClaimsIdentity(claims),

                // Tempo de expiração do nosso token
                Expires = ConfigHelper.TokenExpireInUnit.Equals("seconds") ? DateTime.UtcNow.AddSeconds(ConfigHelper.TokenExpireIn) :
                                                                        DateTime.UtcNow.AddHours(ConfigHelper.TokenExpireIn),
                // Credenciais para incriptar e desincriptar nosso token
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key),
                                                                SecurityAlgorithms.HmacSha256Signature)
            };

            // Criação do token
            var token = tokenHandler.CreateToken(tokenDescriptor);

            return tokenHandler.WriteToken(token);
        }

        public string GenerateRefreshToken()
        {
            var randomNumber = new byte[32];

            using var rng = RandomNumberGenerator.Create();

            rng.GetBytes(randomNumber);

            return Convert.ToBase64String(randomNumber);
        }

        public ClaimsPrincipal GetPrincipalFromExpiredToken(string token)   // Metodo inserido
        {
            var tokenValidationParameters = new TokenValidationParameters
            {
                ValidateAudience = false,
                ValidateIssuer = false,
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(ConfigHelper.JwtKey)),
                ValidateLifetime = false
            };

            var tokenHandler = new JwtSecurityTokenHandler();

            try
            {
                var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out var securityToken);

                if (securityToken is not JwtSecurityToken jwtSecurityToken ||
                        !jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256,
                                                                StringComparison.InvariantCultureIgnoreCase))
                    throw new SecurityTokenException("Invalid Token");
            
                return principal;
            } catch( Exception ex )
            {
                throw ex;
            }

        }

        public async Task SaveRefreshTokenAsync(string username, string token, string refreshToken)     // Metodo inserido
        {
            await _tokenRepository.SaveRefreshTokenAsync( username, token, refreshToken );
        }


        public async Task<string> GetRefreshTokenAsync( string email )      // Metodo inserido
        {
            User user = await _context.Users
                            .AsNoTracking()
                            .FirstOrDefaultAsync( x => x.Email == email );

            if ( user == null )
            {
                throw new Exception("Usuário não cadastrado");
            }

            if ( user.RefreshTokenExpire < DateTime.UtcNow )
            {
                throw new Exception("Refresh Token Expirado");
            } 
            else
            {
                return user.RefreshToken;
            }
        }

        ...
    }

. Insira/Altere as linhas abaixo na classe "AccountController":

    [AllowAnonymous]
    [HttpPost("v1/login")]
    public async Task<IActionResult> Login(                     // Metodo alterado
        [FromBody] LoginViewModel model,
        [FromServices] AppDbContext context,
        [FromServices] TokenService tokenService)
    {
        if (!ModelState.IsValid)
            return BadRequest(new ResultViewModel<string>(ModelState.GetErrors()));

        var user = await context
            .Users
            .AsNoTracking()
            .Include(x => x.Roles )
                .ThenInclude( x => x.Role )
            .FirstOrDefaultAsync(x => x.Email == model.Email);

        if (user == null)
            return StatusCode(401, new ResultViewModel<string>("Usuário ou senha inválidos"));

        if (!PasswordHasher.Verify(user.PasswordHash, model.Password))
            return StatusCode(401, new ResultViewModel<string>("Usuário ou senha inválidos"));


        try
        {
            int refreshTokenExpireIn = 0;
            var token = tokenService.GenerateToken(user);
            string refreshToken = null;

            if ( user.RefreshTokenExpire > DateTime.UtcNow )
            {
                refreshToken = user.RefreshToken;

                refreshTokenExpireIn = (int) user.RefreshTokenExpire.Subtract(DateTime.UtcNow).TotalSeconds;
            }
            else
            {
                refreshToken = tokenService.GenerateRefreshToken();

                // TODO: Fazer refactoring para que a o método "SaveRefreshTokenAsync" retorne o "refreshTokenExpire"                   

                var userRefreshTokenExpire = await context
                    .Users
                    .FromSqlRaw( $"SELECT refreshTokenExpire FROM User WHERE email = '{model.Email}'" )
                    .AsNoTracking()
                    .Select( u => new {
                        refreshTokenExpireIn = u.RefreshTokenExpire
                    })
                    .FirstOrDefaultAsync();

                refreshTokenExpireIn = (int) userRefreshTokenExpire.refreshTokenExpireIn.Subtract(DateTime.UtcNow).TotalSeconds;
            }

            await tokenService.SaveRefreshTokenAsync(model.Email, token, refreshToken);

            return Ok(new ResultViewModel<dynamic>(new 
                                                    { 
                                                        accessToken = token,
                                                        refreshToken = refreshToken,
                                                        tokenType = "Bearer",
                                                        TokenExpireIn = ConfigHelper.TokenExpireIn,
                                                        RefreshTokenExpireIn = refreshTokenExpireIn,
                                                        ExpireUnit = ConfigHelper.TokenExpireInUnit,
                                                    }, null));
        }
        catch ( Exception ex )
        {
            return StatusCode(500, new ResultViewModel<string>($"05X04 - Falha interna no servidor: {ex.Message} "));
        }
    }

. Inclua o método abaixo na classe "AccountController":

    [AllowAnonymous]
    [HttpPost("v1/refreshToken")]
    public async Task<IActionResult> RefreshAsync([FromServices] TokenService tokenService,
                                                    [FromServices] AppDbContext context,
                                                    RefreshTokenViewModel refreshTokenViewModel)
    {
        try
        {
            var principal = tokenService.GetPrincipalFromExpiredToken(refreshTokenViewModel.Token);

            var username = principal.Identity.Name;

            var user = await context
                .Users
                .AsNoTracking()
                .Include(x => x.Roles )
                    .ThenInclude( x => x.Role )
                .FirstOrDefaultAsync(x => x.Email == username);

            if (user.RefreshToken != refreshTokenViewModel.RefreshToken ||
                    user.Token != refreshTokenViewModel.Token )
                return Unauthorized( new { Error =  "Tokens Inválidos"} );

            if ( user.RefreshTokenExpire < DateTime.UtcNow )
            {
                return Unauthorized( new { Error =  "RefreshToken Expirado"} );
            }

            string refreshToken = user.RefreshToken;

            var newJwtToken = tokenService.GenerateToken(user);

            await tokenService.SaveRefreshTokenAsync(username, newJwtToken, refreshToken);

            return new ObjectResult(new
            {
                token = newJwtToken,
                refreshToken = refreshToken
            });
        } catch ( Exception ex )
        {
            return StatusCode(500, new ResultViewModel<string>($"05X04 - Falha interna no servidor: {ex.Message} "));
        }
    }

. Testes

    . Apague o usuario administrator caso exista na base

    . Crie o usuario administrator com a rota abaixo:

        method: POST
        url: https://localhost:5001/account/v1
        body: {
                    "email": "administrator@encoder.com",
                    "Name": "Administrator",
                    "password": "administrator"
                }

        . Guarde o retorno da password para ser utilizado nos proximos logins

            {
                "data": {
                    "user": "administrator@encoder.com",
                    "password": "Jˆ)Q@4qo7Cb#v0!fDKtZx)!HB"
                },
                "errors": []
            }

    . Por se tratar de um usuário "admin", será necessário incluir a role "admin" manualmente no banco,
        execute a DML abaixo no banco de dados:

        INSERT INTO UserRole( UserId, RoleId ) 
        VALUES( 3,  2);
                |   |
                |   +---> RoleId
                |
                +--> UserId

    . Execute o login para ter acesso aos tokens:

        method: POST
        url: https://localhost:5001/account/v1/login
        body: {
                    "user": "administrator@encoder.com",
                    "password": "Jˆ)Q@4qo7Cb#v0!fDKtZx)!HB"
               }


        . Guarde o retorno dos tokens:

            {
                "data": {
                    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1bmlxdWVfbmFtZSI6ImFkbWluaXN0cmF0b3JAZW5jb2Rlci5jb20iLCJyb2xlIjoidXNlciIsIm5iZiI6MTY3MDM1MjEyOSwiZXhwIjoxNjcwMzYyOTI5LCJpYXQiOjE2NzAzNTIxMjl9.j9V5HuVKNjLU8DQB_aZDobwSjdaumSuBYF9Qig_xtiA",
                    "refreshToken": "Sg95Wxiv2d3ewoMXdwUbZXKbMVw7kDzu8AK6VNAPdyI=",
                    "tokenType": "Bearer",
                    "tokenExpireIn": 10800,
                    "refreshTokenExpireIn": 604799,
                    "expireUnit": "seconds"
                },
                "errors": null
            }

    . Insira a grant de "admin" para o usuário "administrator@encoder.com":

        method: POST
        url: https://localhost:5001/account/v1/grant-roles
        body:     [ 
                        { 
                            "Email": "administrator@encoder.com",
                            "RoleName": "admin"
                        }
                    ]
        Header.Authorization: Bearer [accessToken gerado anteriormente]



TESTAR O METODO "await tokenService.SaveRefreshTokenAsync(username, newRefreshToken)" NAS ROTAS LOGIN E RefreshToken


REFATORAR/CRIAR NOVA ROTA PARA ACEITAR UM UNICO ROLE

MUDAR OS CATCH PARA PEGAR A EXCEPTION

COLOCAR CONTROLE DE AUTORIZAÇÃO NOS CONTROLLER




Adicionando CACHE
-----------------


Adicionando Autorização e Autenticação com RefreshToken
-------------------------------------------------------

Adicionando Swagger
-------------------


Adicionando Compressão
----------------------
